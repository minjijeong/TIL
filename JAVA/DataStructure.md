### 배열 Array 
- 초기 사이즈가 고정으로 정의되어야 하는 자료구조
- 초기에 선언되기 때문에 메모리에 연달아 할당됨. 
- 인덱스 기준으로 쉽게 찾을 수 있다. (인덱스 기준으로 조회 시 속도가 빠르다) = cache hit 높다 


### List 
- 초기에 사이즈를 고정하는 옵션도 있지만, 보통은 사이즈 고정없이 목록을 구성한다. 
- 리스트에 자료를 추가할때마다 메모리에 적재되므로 데이터끼리 비슷한 위치에 존재하지 않을 수 있다. 
- 특정 인덱스 기준으로 삭제 추가가 자유롭다. 

### Map 
- key value 기준으로 맵핑되어 있다. 
- key를 모른다면 keyset을 가지고 와서 다시 조회해야 한다. 
- 리스트와 동일하게 메모리 활당이 유동적으로 된다. 

### Queue
- FIFO (First In First Out) 처음 적재된 데이터를 제일 먼저 꺼내쓸수 있다. 
- 데이타 적재된 순서대로 데이타를 꺼낼수 있다. 
- 또는 제일 첫번째 데이터를 peek을 통해 확인 가능하다. 
- Queue.add vs Queue.offer - add()는 빈값을 추가했을때 exception으로 처리, offer()는 빈값이더라도 처리안되고 false 리턴
- Queue<T> queue = new LinkedList<>()

### Stack 
- LIFO (Last in First Out) 마지막에 적재된 데이타를 제일 먼저 꺼낼수 있다. 
- push, pop 으로 적재 또는 꺼내기 가능하다. 
- queue와 동일하게 peek으로 제일 먼저 적재된 데이터를 확인 가능하다 
- Stack<T> stack = new Stack<>(); 

### Deck (Double Ended Queue)
- Deque(Double Ended Queue) 양쪽 끝에서 데이타 추가/삭제 가능하다 
- 연속적인 메모리를 기반으로 하는 '시퀀스 컨테이너'이다. 따라서, 임의 접근 반복자 제공.
- 여러 개의 메모리 단위로 데이터를 저장한다. vector는 메모리를 재할당하고 모든 요소를 복사하여야 하는데, deque는 새로운 메모리 단위를 할당하여 요소를 추가한다.또 데이터 요소를 저장하는 여러 개의 메모리 단위를 갖습니다.
- 크기가 가변적이다. (선언 후에 변경할 수 있다.)
- 중간 요소가 삽입, 삭제될 때, 요소들을 앞/뒤로 밀 수 있으므로 vector보다는 좋은 성능을 갖음. 그래도, 앞/뒤에서의 삽입/삭제 성능은 좋지만 중간에서는 좋지 않다.

### Vector 
- 기존 배열의 크기 제한에 따른 문제를 해결한 것으로 자료구조 중에 배열의 개념을 구현
- **ArrayList와 동일한 기능을 가지고 있어, JAVA에서는 해당 자료형을 거의 쓰지 않고, 호환성 때문에 남겨놓았다.** 
```java
    Vector<Integer> vector = new Vector<>();
    vector.add(5);
    vector.add(4);
    vector.add(3);
    vector.add(-1);
    vector.add(2,100);

    System.out.printf("벡터 안의 요소 객체 수 : %d \n", vector.size());
    System.out.printf("벡터의 현재 용량 : %d \n", vector.capacity());

    for(Integer a : vector){
        System.out.println(a);
    }
        /**
         * 벡터 안의 요소 객체 수 : 5 
         * 벡터의 현재 용량 : 10 
         * 5
         * 4 
         * 100  // 인덱스 2인 위치에 삽입
         * 3    // 그 뒤에 항목들은 뒤쪽으로 한칸씩 밀림 
         * -1
         */
```

### Collection 


### Iterator


### Tree 
- 단하나의 루트 노드가 있고 하위노드들이 연결된 비선형 계층 구조

### Binary Tree 
- 모든 노드가 최대 2개의 자식노드를 가질 수 있는 구조 
- 포화 이진 트리 : 레벨의 노드가 꽉차 있는 
- 완전 이진 트리 : 마지막 레벨 전까지 노드가 차있고 마지막 레벨의 왼쪽에서 오른쪽으로 노드가 채워져 있는 트리 
- 편향 이진 트리 : 왼쪽 혹은 오른쪽 서브 트리만을 가지는 트리. 

### Heap 
- 이진트리의 일종, 여러개의 값 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾을 수 있도록 구성된 자료구조. 
- 시스템의 프로세스의 우선순위를 결정하는 방법으로 많이 사용 
  - 우선순위가 부여된 프로세스를 최대 힙으로 구성하면, 우선순위 숫자가 큰 프로세스가 최상위에 위치하게 됩니다
  - 프로세스를 요청할 때는 최상위 노드에 있는 프로세스를 반환합니다. 
  - 루트 노드가 반환되면 나머지 노드를 우선순위 숫자에 근거하여 트리 구조를 재구성하고, 가장 높은 우선순위를 가지는 프로세스가 루트 노드에 위치하게 됩니다. 
  

### Grape 
#### DFS(Deotg First Search)
- 시작 정점에서 한 방향으로 갈 수 있는 가장 먼 경로까지 탐색하다가 갈 곳이 없으면, 가장 마지막에 만났던 부모 노드로 돌아와서 다른 방향을 탐색하는 방법 
  

#### BFS(Breadth First Search)
- 시작 정점에서 인접한 모든 정점들을 우선 방문한 후, 더 이상 방문하지 않은 정점이 없을 때까지 방문했던 정점들을 다시 시작점으로 해서 모든 정점들을 차례로 방문하는 방법
  




