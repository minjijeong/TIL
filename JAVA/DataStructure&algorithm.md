### 배열 Array 
- 초기 사이즈가 고정으로 정의되어야 하는 자료구조
- 초기에 선언되기 때문에 메모리에 연달아 할당됨. 
- 인덱스 기준으로 쉽게 찾을 수 있다. (인덱스 기준으로 조회 시 속도가 빠르다) = cache hit 높다 


### List 
- 초기에 사이즈를 고정하는 옵션도 있지만, 보통은 사이즈 고정없이 목록을 구성한다. 
- 리스트에 자료를 추가할때마다 메모리에 적재되므로 데이터끼리 비슷한 위치에 존재하지 않을 수 있다. 
- 특정 인덱스 기준으로 삭제 추가가 자유롭다. 

### Map 
- key value 기준으로 맵핑되어 있다. 
- key를 모른다면 keyset을 가지고 와서 다시 조회해야 한다. 
- 리스트와 동일하게 메모리 활당이 유동적으로 된다. 

### Queue
- FIFO (First In First Out) 처음 적재된 데이터를 제일 먼저 꺼내쓸수 있다. 
- 데이타 적재된 순서대로 데이타를 꺼낼수 있다. 
- 또는 제일 첫번째 데이터를 peek을 통해 확인 가능하다. 
- Queue.add vs Queue.offer - add()는 빈값을 추가했을때 exception으로 처리, offer()는 빈값이더라도 처리안되고 false 리턴
- Queue<T> queue = new LinkedList<>()

### Stack 
삽입과 삭제가 한쪽 끝에서 이루어지는, 순서가 매겨진 리스트이다. 
- LIFO (Last in First Out) 후입선출 마지막에 적재된 데이타를 제일 먼저 꺼낼수 있다. 
  (= FILO, First In Last Out) 선입후출 
- push(삽입), pop(삭제) 으로 적재 또는 꺼내기 가능하다. 
- queue와 동일하게 peek으로 제일 먼저 적재된 데이터를 확인 가능하다 
- Stack<T> stack = new Stack<>(); 
- top : 스택에 마지막에 추가된 항목을 삭제하지 않고 리턴 
- isEmptyStack : 스택에 항목이 저장되어 있는지 확인
- isFullStack : 스택이 가득 찼는지 아닌지를 확인
  

### Deck (Double Ended Queue)
- Deque(Double Ended Queue) 양쪽 끝에서 데이타 추가/삭제 가능하다 
- 연속적인 메모리를 기반으로 하는 '시퀀스 컨테이너'이다. 따라서, 임의 접근 반복자 제공.
- 여러 개의 메모리 단위로 데이터를 저장한다. vector는 메모리를 재할당하고 모든 요소를 복사하여야 하는데, deque는 새로운 메모리 단위를 할당하여 요소를 추가한다.또 데이터 요소를 저장하는 여러 개의 메모리 단위를 갖습니다.
- 크기가 가변적이다. (선언 후에 변경할 수 있다.)
- 중간 요소가 삽입, 삭제될 때, 요소들을 앞/뒤로 밀 수 있으므로 vector보다는 좋은 성능을 갖음. 그래도, 앞/뒤에서의 삽입/삭제 성능은 좋지만 중간에서는 좋지 않다.

### Vector 
- 기존 배열의 크기 제한에 따른 문제를 해결한 것으로 자료구조 중에 배열의 개념을 구현
- **ArrayList와 동일한 기능을 가지고 있어, JAVA에서는 해당 자료형을 거의 쓰지 않고, 호환성 때문에 남겨놓았다.** 
```java
    Vector<Integer> vector = new Vector<>();
    vector.add(5);
    vector.add(4);
    vector.add(3);
    vector.add(-1);
    vector.add(2,100);

    System.out.printf("벡터 안의 요소 객체 수 : %d \n", vector.size());
    System.out.printf("벡터의 현재 용량 : %d \n", vector.capacity());

    for(Integer a : vector){
        System.out.println(a);
    }
        /**
         * 벡터 안의 요소 객체 수 : 5 
         * 벡터의 현재 용량 : 10 
         * 5
         * 4 
         * 100  // 인덱스 2인 위치에 삽입
         * 3    // 그 뒤에 항목들은 뒤쪽으로 한칸씩 밀림 
         * -1
         */
```

### Collection 


### Iterator


### Tree 
단하나의 루트 노드가 있고 하위노드들이 연결된 비선형 계층 구조
뿌리(Root) : 부모가 없는 노드
간선(Edge) : 부모로부터 자식에게 이어지는 연결 선
잎(Leaf) : 자식이 없는 노드
형제(Siblings) : 같은 부모를 가진 자식들
레벨 : 주어진 깊이의 모든 노드의 집합 (같은 깊이)
노드의 깊이 : 뿌리로부터 그 노드까지의 경로의 길이
노드의 높이 : 그 노드부터 가장 깊은 노드까지의 경로의 길이
트리의 높이 : 트리의 모든 노드의 높이 중 최대 값
트리의 깊이 : 트리의 모든 노드의 깊이의 최대 값
노드의 크기 : 자기 자신을 포함하여 그 노드가 가진 자손의 수 
경사(skew) : 트리의 모든 노드가 오직 한 개의 자식만을 가진 트리(잎노드 제외) 
- 오른쪽 자식만 있으면 오른쪽 경사 트리
- 왼쪽 자식만 있으면 왼쪽 경사트리  


### Binary Tree 
모든 노드가 최대 2개의 자식노드를 가질 수 있는 구조 
(빈 트리 역시 유효한 이진 트리)
- 엄격한 이진 트리 : 모든 노드가 두 개의 자식을 가지거나 자식이 없는 트리
- 포화 이진 트리 : 모든 노드가 두 개의 자식을 가지고 잎 노드가 같은 레벨에 있는 노드 
- 완전 이진 트리 : (확인필요) 뿌리부터 시작해서 각 노드에 번호를 매기면 1~ 트리 안의 노드 수까지의 완전한 순열을 얻는다. 
  * 완전 이진트리는 마지막 레벨을 제외 하고 모든 레벨이 완전히 채워져 있다.
  * 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
  * 마지막 레벨 h에서 1~2h-1 개의 노드를 가질 수 있다.
  * 완전 이진 트리는 배열을 사용해 효율적으로 표현 가능하다.

- 편향 이진 트리 : 왼쪽 혹은 오른쪽 서브 트리만을 가지는 트리. 

### Heap 
- 이진트리의 일종, 여러개의 값 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾을 수 있도록 구성된 자료구조. 
- 시스템의 프로세스의 우선순위를 결정하는 방법으로 많이 사용 
  - 우선순위가 부여된 프로세스를 최대 힙으로 구성하면, 우선순위 숫자가 큰 프로세스가 최상위에 위치하게 됩니다
  - 프로세스를 요청할 때는 최상위 노드에 있는 프로세스를 반환합니다. 
  - 루트 노드가 반환되면 나머지 노드를 우선순위 숫자에 근거하여 트리 구조를 재구성하고, 가장 높은 우선순위를 가지는 프로세스가 루트 노드에 위치하게 됩니다. 
  

### Grape 
#### DFS(Deotg First Search)
- 시작 정점에서 한 방향으로 갈 수 있는 가장 먼 경로까지 탐색하다가 갈 곳이 없으면, 가장 마지막에 만났던 부모 노드로 돌아와서 다른 방향을 탐색하는 방법 
  

#### BFS(Breadth First Search)
- 시작 정점에서 인접한 모든 정점들을 우선 방문한 후, 더 이상 방문하지 않은 정점이 없을 때까지 방문했던 정점들을 다시 시작점으로 해서 모든 정점들을 차례로 방문하는 방법
  




### 재귀와 백트래킹 
#### 재귀 
자기 자신을 호출하는 함수를 재귀적이라고 부른다. 
재귀단계 - 재귀적 방법은 자신의 복사본을 호출하여 더 작은 문제를 풀게함으로써 문제를 해결한다. 

```
if(기본 경우인지 테스트)
  return 기본 경우 값 
else if(또 다른 기본 경우 테스트)
  retrun 다른 기본 경우 값
// 재귀경우
else
  return (어떤작업) 그런 다음(재귀호출)
```


##### 재귀 vs 반복 
|재귀|반복|
|--|--|
|기본 경우에 도달하면 종료한다. | 조건이 거짓이 될 때 종료한다. |
|각 재귀 호출은 스택 프레임(즉 메모리)에 부가 공간을 필요로 한다. | 각 반복이 부가 공간을 필요로 하지 않는다. | 
|무한 재귀에 들어가게 되면 메모리 용량을 초과해서 스택 오버플로우를 초래하게 된다. | 무한 루프는 추가 메모리가 필요하지 않으므로 무한히 반복된다. |
| - | 반복적 해법은 재귀적 해법에 비해 간단하지 않을 때가 있다|

#### 백트래킹 
분할 정복을 이용한 완전 검색 기법 
- 모든 경우의 수를 다 잘펴 볼수 있다.
- 가지치기를 이용해 완전 검색을 빠르게 한다. 


### 연결리스트 
- 연속되는 항목들이 포인터로 연결된다. 
- 마지막 항목은 null을 포인트한다. 
- 프로그램이 수행되는 동아 ㄴ크기가 커지거나 작아질 수 있다. 
- 메모리 공간을 낭비하지 않는다.(포인터르 ㄹ위한 추가의 메모리를 필요로 한다.)
- (시스템 메모리가 허용하는 한) 필요한 만큼 길어질 수 있다. 
  
#### 배열 vs 연결리스트 
연결리스트와 배열 모두 데이터 집합을 저장하기 위해 사용된다. 
배열은 항목에 접근이 더 빠르지만, 고정된 크기, 한 블록의 할당이 어렵거나, 특정 위치에 데이타를 삽입 시, 기존항목들을 이동을시켜야지만 삽입 가능하므로 어려움이 있다. 

연결리스트를 사용하면 하나의 항목을 위한 공간으로 시작해서 복사나 재할당 없이 새항목을 쉽게 추가할 수 있다. 
다만, 개별항목에 접근하는 접근 시간이 배열에 비해 길다. 

### 이중연결리스트 
리스트의 특정노드로부터 양방향으로 탐색가능 

이중연결리스트 단점 
- 각 노드가 포인터를 하나씩 더 필요로 하기 때문에 저장 공간이 더 필요하다. 
- 삽입, 삭제 연산이 조금 더 오래 걸린다(포인터 연산이 더 많아져서이다).
  
### 원형연결리스트 
단일, 이중 연결리스트와 달리 맨 끝의 노드라는 것이 존재하지 않아. 노드의 다음노드가 null인 노드가 존재하지 않는다. 
* 노드 개수 세기
  임의의 노드를 시작점으로 선택하고 다음노드가 시작 노드와 같아질때까지 순환하며 개수를 센다. 

