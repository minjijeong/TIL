## CS 질문
### 운영체제 
- 컴퓨터 시스템의 하드웨어, 소프트웨어적인 자원들을 효율적으로 운영 및 관리함으로써 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 하는 시스템 소프트웨어


### 가상 메모리
- 메모리가 실제 메모리보다 많아 보이게 하는 기술
- 프로세스 간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음
- CPU는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근 하드웨어 장치를 이용해야 주소 변환이 빠르므로 별도 장치를 둔다


#### 메모리 
- 컴퓨터에서 작업을 수행하기 위해 처리 대상이나 결과 등을 저장하기 윈한 공간




### 프로세스 vs. 스레드
```
메인 차이점은 프로세스는 프로그램의 실행되고 있는 인스턴스이고, 쓰레드는 프로세스 내에서 할당받은 자원을 이용하여 동작하는 실행 단위를 뜻한다. 

특히 code, data, heap등을 공유하는 쓰레드와 달리 프로세스는 서로 데이타 공유는 불가하여 IPC라는 통신을 통해서만 데이타를 교환할 수 있다. 
```
- 프로그램 : 어떤 작업을 위해 실행 할 수 있는 파일(정적코드)
- 인스턴스 : 구체적 사례, 예제
  
- 프로세스 : 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 
  - 운영체제로 부터 독립된 메모리 영역을 할당
  - 다른 프로세스와 메모리 공유를 안하기때문에 통신하기 위해서 IPC를 사용
  - 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있다. 
  
- 쓰레드 : 프로세스 내에서 할당받은 자원을 이용해 동작하는 실행 단위
  - 각 쓰레드는 Stack만 개별적으로 할당 받고, Code, Data, Heap은 공유한다. 
    (Stack에는 함수 호출 정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복자해지기 때문에 실행의 흐름을 원할하게 함이다...stack 공유하면 쓰레드 간의 호출순서가 뒤죽박죽 일수 있음)
  - 쓰레드의 실행 
    - 쓰레드를 생성했다고 실행되지 않는다. start를 호출해야지 쓰레드 실행 
    - start 호출을 하면 BlockingQueue에 적재되어 실행대기 상태로 있다가 OS 스케줄러가 작성한 스케줄에 의해 결정된다. 
    - 한번 종료된 쓰레드는 다시 실행할 수 없다. (하나의 쓰레드에 start는 **한 번만 호출**될 수 잇다. ) 
    - start() 와 run()
    - main에서 run은 쓰레드 실행이 아니라, 클래스에 선언된 메서드를 호출시키는 것일뿐이다. 
    - start() 쓰레드를 위해 호출스택을 생성한 후 run()을 호출해서 생성된 호출스택에 run()이 첫번째로 올라가게 한다. 











#### BlockingQueue
- Queue가 꽉찼을 때 삽입시도, 비었을 때 추출 시도를 막는다. 
- Thread safe하다 
- 종류 
  - ArrayBlockingQueue (배열로 구현된 큐) 
    - block된 thread들 순차자거 대기열 생성
    - 대기열의 순서는 보장되지 않지만, 공평성을 따지기 때문에 Thread 기아현상을 줄인다 
    - *add는 큐 최대크기를 따지지 않고 삽입하여 Exception 발생가능, put은 최대크기를 따져 더이상 삽입하지 못하는 상태라면 wait하기 때문에 안전*
  
  - LinkedBlockingQueue (LinkedList로 구현된 큐)
    - 하나의 큐에 대해 동시 사용이 높은 환경(동시성 App)에서 ArrayBlockingQueue보다 높은 처리율(throughput)을 보인다. 
  
  - PriorityBlockingQueue 
    - PriorityQueue와 같은 정렬방식을 지니는 용량 제한이 없는 Queue. Element추출에 대해 block 기능을 제공
    - 입력무제한(unbounded)으로 기본설계가 되었기 때문에 추가작업 수행중 fail이 나면 이것은 자원고갈이 났다는 뜻 (OutofMemoryError)
    - null element및 non-comparable object를 수용하지 않으며 natural ordering을 지원 (ClassCastException)
  
  - PriorityBlockingQueue..(to be continue..)










### 데드락(Deadlock) 
= 교착상태 
- 한정된 자원을 여러 프로세스가 사용하고자 할때 발생하는 상황. 프로세스가 자원을 얻기 위해 영구적으로 대기하하는 상태를 말한다.
- 발생조건 
  - 상호 배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다.
  - 점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재
  - 비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없다. 
  - 순환 대기 : 대기 프로세스의 집합이 순환형태로 자원을 대기하고 있어야 한다.  
- 해결방법
  - **탐지하여 회복** : 데드락이 발생한 트랜잭션 중 하나를 강제 중지시킨다. 중지한 트랜잭션은 회복시킴
  - 예방 : 할당 구조 측면에서, 데드락이 발생할 수 있는 요구조건을 만족시키지 않게 함으로써 데드락을 방지한다.
  - 회피 : 리소스 할당 측면에서 데드락 가능성 있는 자원을 할당(Allocation) 하지 않는다.

- 예시 
  - 쇼핑몰 재고처리
    - 마이너스 재고 허용, 주기적으로 마이너스 재고인 경우 확인 후 직접 주문 취소 또는 어드민 쪽 알림 처리 세팅 했던것으로 기억
    - 마켓컬리 케이스 - 안정상태일때만 차감. 트랜젝션을 상품단위로 지정, 재고 증가/차감 큐 처리하기전 상품기준으로 소팅하여 처리
    (대용량 트래픽을때.. 쏘팅하는 것이 안느릴지...? 이부분은 어떻게 하면 좋을지)

참고 예제 
https://helloworld.kurly.com/blog/vsms-performance-experiment/














### 동기 vs. 비동기
- 동기(Synchronous) : 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식
  > 호출하는 함수가 호출되는 함수의 작업 완료 후 리턴을 기다리거나, 또는 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수.
  - 순서에 맞추어 진행되어 제어가 쉽다
  - 여러 요청을 동시에 처리할 수 없어 효율성이 떨어진다
- 비동기(Asynchronous) : 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청 동작하는 방식
  > 호출되는 함수에게 callback을 전달해서, 호출 되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, **호출하는 함수는 작업 완료 여부를 신경쓰지 않는다.**
  - 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적 운용 가능
  - 작업 완료된 결과를 제어하기 어렵다 (언제 끝나는지 모르거나 상관없어서..?)


### 컨텍스트 스위칭(Context Switching)
```
컨텍스트 스위칭 발생 시, 기존의 작업을 저장해야하기 때문에 프로세스는 서로 메모리 공유가 없어 전체를 저장해야 하지만, 
쓰레드는 스택외 데이타, 힙, 코드를 공유하기때문에 상대적으로 비용이 적게 든다.
```
- 인터럽트를 발생시켜 CPU에서 실행중인 프로세스를 중단하고, 다른 프로세스를 처리하기 위한 과정 
  *현재 실행중인 프로세스의 상태(context)를 먼저 SP(Stack Pointer)에 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구한다.* 
  - 인터럽트 : CPU가 프로세스를 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요함을 CPU에 알리는 것 
  






### 멀티 프로세스 vs 멀티 쓰레드 
#### 멀티 쓰레드 프로그래밍 작성 시, 유의점 
```
다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우 상호 배제를 제거해 교착상태를 예방하고 동기화 기법을 통해 동시성 문제가 발생하지 않도록 주의
``` 
- 멀티 프로세스 : 하나의 프로그램을 여러 개의 프로세로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는것 
  - 1개의 프로세스가 죽어도 자식 프로세스 이외의 다른 프로세스들은 계속 실행
  - Context Switching을 위한 오버헤드(캐시 초기화, 인터럽트 등)가 발생한다. 
  - 프로세스는 각각 독립적인 메모리를 할당받았기 때문에 통신하는 것이 어렵다. 
  
- 멀티 쓰레드 : 하나의 프로그램을 여러개의 쓰레드로 구성하여 각 쓰레드가 1개의 작업을 처리하도록 하는 것
  - 프로세스를 위해 자원을 할당하는 시스템콜이나 Context Switching의 오버헤드를 줄일 수 있다. 
  - 쓰레드는 메모리를 공유하기 때문에, 통신이 쉽고 자원을 효율적으로 사용 가능
  (각 쓰레드는 스택을 제외한 data, heap, code 공유)
  - 하나의 쓰레드에 문제가 생기면 전체 프로세스가 영향을 받는다 
  - 여러 쓰레드가 하나의 자원에 동시에 접근하는 경우 자원 공유(동기화)의 문제가 발생할 수 있다. 


<details>
<summary>CS 질문 작업중..</summary>
<div markdown="1">
## 페이징 시스템
## 세그먼테이션
## 동기화
## 뮤텍스
## 세마포어
## 임계영역(Critical Section)
## 상호배제
</div>
</details>
<br>


## 자료구조
### Stack vs. Queue
- Stack : LIFO, 별도의 구현체 존재
- Queue : FIFO, LinkedList로 구현하면 삽입, 삭제가 용이하다
  
### Array vs. List 
- 배열과 List는 데이타 순차적이지 않은 추가/삭제 시, 비용 부분에 차이가 가장 크다. 
- 배열은 정적 데이타 타입으로 컴파일 시, 메모리에 할당된다. 
- null 허용 

### ArrayList vs. LinkedList
```
ArrayList 데이타가 연속적으로 메모리 할당되어 존재하지만, LinkedList는 불연속적으로 존재하는 데이터를 주소값을 가지고 서로 연결한 형태로 구성 
- 데이터를 무작위 접근을 위해서는 ArrayList를 선택 
- 데이터의 추가/삭제가 빈번하게 일어난다면 LinkedList 선택 
```
- ArrayList : 배열에 더 이상 저장할 새로운 공간이 없으면 보다 큰 새로운 배열을 생성하여 기존에 내용을 복사한 다음에 저장
  - Array가 가지는 특징 동일하게 가짐. 
    - 동기화를 지원하지 않는다.
    - 데이터를 읽어오는 데 걸리는 시간이 가장 빠르다. index로 직접 접근, 저장은 용이함
    - 비순차적인 데이타 추가/삭제가 비용이 많이든다 (시간, 공간)
    - 
    ```java
    public class ArrayList extends abstractList
    implements List, RandomAccess, Cloneable, java.io.Serializable {
    ...
    // 배열로 선언됨
    transient Object[] elementData;  // Object 배열
    ...
    }
    ```
- LinkedList 
  - 리스트의 크기에 영향 없이 데이터를 추가/삭제 할수 있다. 
  - 데이터를 추가하기 위해 노드를 생성하여 연결하므로 연산이 빠르다
  - 무작위 접근이 불가능(Index 통해서), 순차 접근만이 가능하다. 


### 그래프
- 정점과 간선의 집합. 각 정점에 연결된 Edge의 개수를 차수(Degree)라 한다.
  - 무향 그래프 : 정점과 간선 사이에 방향성이 없는 그래프
  - 유향 그래프 
  - 가중치 그래프 : 간선에 가중치 정보를 두어 구성한 그래프
  - 부분 그래프 : 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프
- 그래프 구현 방법 
  - 인접 행렬 (adjacent matrix) : 정방 행렬을 사용. O(V^2) Space Complexity를 가진다.
  - 인접 리스트 (adjacent list) : 연결 리스트 사용. O(E(edge)+V(value)) Space Complexity. 
  
### 깊이 우선 탐색 DFS (Depth First Search)
- 한 쪽 정점으로만 나아가는 방법으로 우선순위 탐색. 
  - 자료구조 **Stack**을 사용 or 재귀로 구현한다.  
  - 그래프의 높이 만큼의 공간만을 요구함. 
  - 최단 경로가 된다는 보장이 없다.
  - Time Complexity : O(V+E) … vertex 개수 + edge 개수 
```java
public class Dfs {
    static ArrayList<ArrayList<Integer>> adj;
    // 방문 이력 체크
    static boolean[] visited;


    static void dfs(int cur) {
        visited[cur] = true;

        for(int next : adj.get(cur)) {
            if(!visited[next])
                dfs(next);
        }

    }

  // 모든 노드들을 탐색하기 위함
    static void dfsAll() {
        Arrays.fill(visited, false);
        for(int i = 0; i < adj.size(); i++)
            if(!visited[i])
                dfs(i);
    }
}
```

### 너비 우선 탐색 BFS (Breadth First Search)
- 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다. 
  **Queue**를 사용. vertex 들을 방문한 순서대로 queue에 저장하는 방법을 사용
  - 목표 노드가 깊은 단계에 있을 경우 오랜 시간이 소요되고, 공간 복잡도가 크다
  - Time Complexity : O(V+E) … vertex 개수 + edge 개수 BFS 로 구한 경로는 최단 경로이다.
```java
public class Bfs {
    static ArrayList<ArrayList<Integer>> adj;
    static boolean[] discovered;


    static void bfs(int start) {
        Queue<Integer> q = new LinkedList<Integer>()
        q.add(start); // 시작점 주입

        while(!q.isEmpty()) {
            int cur = q.poll();
            discovered[cur] = true;
            // 다음 노드 확인 
            for(int next : adj.get(cur)) {
                if(!discovered[next]) { // 미방문한 노드
                    q.add(next);
                    discovered[next] = true;
                }
            }
        }

    }
}
```

### 이진 검색 트리 (Binary Search Tree)
TreeSet - 이진 검색 트리의 형태로 데이터를 저장하는 컬렉션 프레임워크
- 모든 노드는 최대 두개의 자식 노드를 가질 수 있다. 
- 왼쪽 노드의 값은 부모 노드의 값보다 작고 오른쪽 노드의 값은 부모 노드의 값보다 크다. 
- 노드의 추가/삭제에 시간이 걸린다. (LinkedList에 비교하면, 순차적으로 접근이 아니므로)
- 검색(범위 검색)과 정렬에 유리하다. (LinkedList에 비교하면)
- 중복된 값을 저장하지 못한다. **이건왜?? 다시확인!!** 
  







### 우선순위 큐와 힙
#### 우선순위 큐
- 저장된 순서와 상관없이, 우선순위가 높은 데이타가 먼저 나오는 자료구조 
  - 연결리스트, 힙 기반 구현
    ##### 힙
    - 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조
    - 각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리   
  - 시간복잡도 O(logn)
  - null 저장 시 NullPointerException 발생



### Hash함수
- 고유한 인덱스 값을 설정하는 것이 주요 역할 
  - Division Method : 나눗셈을 이용하여 입력값을 테이블의 크기로 나누어 계산
  - Digit Folding : 각 key의 문자열을 ASCII 코드로 바꾸어 값을 합한 데이터를 테이블 내의 주소로 사용
  - Mutiplication Method : 숫자로 된 K와 0과 1 사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 연산 
    - h(k) = (k*A mod 1) * m
  - Univeral Hashing : 다수의 해시함수를 만들어 집합 H에 넣어두고 무작위로 해시함수를 선택해 해시값을 만드는 기법

- **해시(Hash)값이 충돌하는 경우(Resolve Collision : 충돌 해결)**
  #### Open Addressing (개방 주소법)
  - 비어 있는 해시 테이블의 공간을 활용하는 방법
    1. Linear Probing : 현재의 버킷 index로부터 고정폭 만큼 이동하여 차례대로 검색해 비어 잇는 버킷에 데이터를 저장
    2. Quadratic Probing : 해시의 저장 순서 폭을 제곱으로 저장하는 방식.
    3. Double Hashing Probing : 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 거친다.  
  - *Open Addressing에서 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되는데, 그렇기 때문에 Hash Table을 재정리 해주는 작업이 필요하다고 한다.*  

  #### Separate Chaining (분리 연결법) 
  - 동일한 버킷(인덱스)의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장  
    (헤싱룰에 의해 동일 인덱스에 할당되었을 때, 해당인덱스 엔티티 뒤에 연결리스트로 붙인다)
  - 데이터의 수가 많아지면, 동일한 버킷에 chaining되는 데이터가 많아지며 캐시의 효율성이 감소
    (링크드리스트 or 트리로 이루어져 있기때문에 인덱스에 직접 접근이 아니라 노드를 순차적 접근하므로...)







### HashTable
- (Key, Value)로 데이터를 저장하는 자료구조
  -  빠른 검색속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문
  -  각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다
  -  시간복잡도 : 평균 O(1)의 시간복잡도로 데이터를 조회, 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야 하므로 O(N)까지 시간복잡도가 증가

- java7 : Sperate Chaining 사용. 충돌 시 해시 테이블 인덱스에 연결 리스트를 이용해서 여러 값을 연결한 형태로 저장한다.
  - 해시 함수가 고른 분포를 만들지 못하면 성능에 치명적이다
  - 각 element의 hash 값이 한 인덱스에 몰려 모든 value가 연결된다면, value를 찾아내는데는 연결 리스트를 모두 탐색해야하므로 최악의 경우 O(n)의 성능을 갖을 수 있다.
- java8 : 버킷 8개 이상의 데이터가 쌓이면 링크드 리스트에서 트리로 변경, 다시 6개 이하가되면 링크드리스트로 변경
  - 오버헤드를 고려하여 8/6 2의 차이를 둠


### HashMap vs HashTable
```
HashTable의 put에는 synchronized 키워드가 붙어, 동기화 지원을 해주고, 
HashMap은 동기화 지원을 고려하지 않아도 되는 상황에 사용 가능
```


참고 
https://bcho.tistory.com/1072
출처: https://mangkyu.tistory.com/102 [MangKyu's Diary:티스토리]







<details>
<summary>자료구조 작업중..</summary>
<div markdown="1">
### Full Binary Tree vs. 완전 이진 트리 Complete Binary Tree
### 이진트리 순회
### Binary Heap
### Hash Function
### Graph Search
### Graph Implement
### Adjacent matrix (인접 행렬)
### Adjacent list (인접 리스트)
</div>
</details>
<br>


## 알고리즘 
![javaIndependent](https://blog.kakaocdn.net/dn/chRU1M/btq21CiivQu/Tpw9ZkJB7Y5EG5aSv2kv0K/img.png)


### 버블소트
- 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘입니다. 
- 0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬합니다. 
- 시간복잡도는 O(n^2) 입니다.
```java
public static void bubleSort(int[] arr) {    
  for(int i = 0; i < arr.length; i++) {        
    for(int j = 0 ; j < arr.length - i - 1 ; j++) {            
      // 앞이 뒤보다 크면 자리 바꾸기
      if(arr[j] > arr[j+1]) {                
        int temp = arr[j+1];                
        arr[j+1] = arr[j];                
        arr[j] = temp;            
      }        
    }    
  }
}
```
 
### 힙소트
- 주어진 데이터를 힙 자료구조로 만들어 **최대값 또는 최소값부터 하나씩 꺼내서 정렬**하는 알고리즘입니다. 
- 힙소트가 가장 유용한 경우는 전체를 정렬하는 것이 아니라 가장 큰 값 몇개만을 필요로 하는 경우입니다. 
- 시간복잡도는 O(nlog_2n) 입니다.
  - 우선순위가 가장 높은 노드가 root노드, 배열로 치자면 첫 번째 원소를 의미하고 있다.
  - **우선순위 큐** 자료구조를 구현하는데 기반

 
### 머지소트
- 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 **분할/정복 알고리즘**입니다.
- 시간복잡도는 𝑂(𝑛𝑙𝑜𝑔2𝑛)O(nlog2n)O(nlog_2n) 입니다.
참고 : https://st-lab.tistory.com/233















```java
private static void merge(int[] a, int left, int mid, int right) {
	int l = left;		// 왼쪽 부분리스트 시작점
	int r = mid + 1;	// 오른쪽 부분리스트의 시작점 
	int idx = left;		// 채워넣을 배열의 인덱스
	
	
	while(l <= mid && r <= right) {
		/*
		 *  왼쪽 부분리스트 l번째 원소가 오른쪽 부분리스트 r번째 원소보다 작거나 같을 경우
		 *  왼쪽의 l번째 원소를 새 배열에 넣고 l과 idx를 1 증가시킨다.
		 */
		if(a[l] <= a[r]) {
			sorted[idx] = a[l];
			idx++;
			l++;
		}
		/*
		 *  오른쪽 부분리스트 r번째 원소가 왼쪽 부분리스트 l번째 원소보다 작거나 같을 경우
		 *  오른쪽의 r번째 원소를 새 배열에 넣고 r과 idx를 1 증가시킨다.
		 */
		else {
			sorted[idx] = a[r];
			idx++;
			r++;
		}
	}
		
	/*
	 * 왼쪽 부분리스트가 먼저 모두 새 배열에 채워졌을 경우 (l > mid)
	 * = 오른쪽 부분리스트 원소가 아직 남아있을 경우
	 * 오른쪽 부분리스트의 나머지 원소들을 새 배열에 채워준다.
	 */
	if(l > mid) {
		while(r <= right) {
			sorted[idx] = a[r];
			idx++;
			r++;
		}
	}
		
	/*
	 * 오른쪽 부분리스트가 먼저 모두 새 배열에 채워졌을 경우 (r > right)
	 * = 왼쪽 부분리스트 원소가 아직 남아있을 경우
	 * 왼쪽 부분리스트의 나머지 원소들을 새 배열에 채워준다.
	 */
	else {
		while(l <= mid) {
			sorted[idx] = a[l];
			idx++;
			l++;
		}
	}
	
	/*
	 * 정렬된 새 배열을 기존의 배열에 복사하여 옮겨준다.
	 */
	for(int i = left; i <= right; i++) {
		a[i] = sorted[i];
	}
}
```


 
### 퀵소트
- 매우 빠른 정렬 속도를 자랑하는 분할 정복 알고리즘 중 하나로 합병정렬과 달리 리스트를 비균등하게 분할합니다. 
- 피봇을 설정하고 피봇보다 큰값과 작은값으로 분할하여 정렬을 합니다. 
- 시간복잡도는 O(nlog_2n) 이며 리스트가 계속해서 불균등하게 나눠지는 경우 시간복잡도가 O(n^2) 까지 나빠질 수 있습니다.
- 재귀 알고리즘을 이용
```java
public class QuickSorter {
    public static List<Integer> quickSort(List<Integer> list) {
        if (list.size() <= 1) return list;
        int pivot = list.get(list.size() / 2);

        List<Integer> lesserArr = new LinkedList<>();
        List<Integer> equalArr = new LinkedList<>();
        List<Integer> greaterArr = new LinkedList<>();

        for (int num : list) {
            if (num < pivot) lesserArr.add(num);
            else if (num > pivot) greaterArr.add(num);
            else equalArr.add(num);
        }

        return Stream.of(quickSort(lesserArr), equalArr, quickSort(greaterArr))
                .flatMap(Collection::stream)
                .collect(Collectors.toList());
    }
}
```



 
### 삽입정렬
- 두 번째 값부터 시작하여 그 앞(타겟보다 앞)에 존재하는 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘
- 삽입 정렬의 평균 
- 시간복잡도는 O(n^2) 이며, 가장 빠른 경우 O(n) 까지 높아질 수 있습니다.

```java
public class Insertion_Sort {
 
	public static void insertion_sort(int[] a) {
		insertion_sort(a, a.length);
	}
	
	private static void insertion_sort(int[] a, int size) {		
		for(int i = 1; i < size; i++) {
			// 타겟 넘버
			int target = a[i];
			
			int j = i - 1;
			
			// 타겟이 이전 원소보다 크기 전 까지 반복
			while(j >= 0 && target < a[j]) {
				a[j + 1] = a[j];	// 이전 원소를 한 칸씩 뒤로 미룬다.
				j--;
			}
			
			/*
			 * 위 반복문에서 탈출 하는 경우 앞의 원소가 타겟보다 작다는 의미이므로
			 * 타겟 원소는 j번째 원소 뒤에 와야한다.
			 * 그러므로 타겟은 j + 1 에 위치하게 된다.
			 */
			a[j + 1] = target;	
		}
		
	}
}
```

### 선택정렬
- 리스트에서 최솟값을 찾고, 맨 앞자리의 값과 교환 -> 두번째 자리부터 나머지 값들 중 최솟값을 찾고 반복
- 시간복잡도가 O(N^2) 

```java
public class Selection_Sort {
 
	public static void selection_sort(int[] a) {
		selection_sort(a, a.length);
	}
	
	private static void selection_sort(int[] a, int size) {
		
		for(int i = 0; i < size - 1; i++) {
			int min_index = i;	
			
			// 최솟값을 갖고있는 인덱스 찾기 
			for(int j = i + 1; j < size; j++) {
				if(a[j] < a[min_index]) {
					min_index = j;
				}
			}
			
			// i번째 값과 찾은 최솟값을 서로 교환 
			swap(a, min_index, i);
		}
	}
	
	private static void swap(int[] a, int i, int j) {
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	
}
```



### 기수 정렬(Radix sort)
- 추가적인 메모리가 필요하고 데이터 타입이 숫자,문자만 가능하도록 제한됨 
- 시간복잡도 O(n)

```java
public class Main {
	static final int bucketSize = 10;
	
	public static void main(String[] args) {
		int[] arr = {28, 93, 39, 81, 62, 72, 38, 26};
		
		radix_Sort(arr.length, arr);
		
		for (int i = 0; i < arr.length; ++i) {
			System.out.print(arr[i] + " ");
		}
	}
	
	public static void radix_Sort(int n, int[] arr) {
		//bucket 초기화
		Queue<Integer>[] bucket = new LinkedList[bucketSize];
		for (int i = 0; i < bucketSize; ++i) {
			bucket[i] = new LinkedList<>();
		}
		
		int factor = 1;
		
		//정렬할 자릿수의 크기 만큼 반복한다.
    //일의 자리 정렬 -> 10의 자리 추가 정렬 ... -> N의 자리 정렬
		for (int d = 0; d < 2; ++d) {
			for (int i = 0; i < n; ++i) {
				bucket[(arr[i] / factor) % 10].add(arr[i]);
			}
			
			for (int i = 0, j = 0; i < bucketSize; ++i) {
				while (!bucket[i].isEmpty()) {
					arr[j++] = bucket[i].poll();
				}
			}
			
			factor *= 10;
		}
	}
}
```

### 알고리즘의 성능 분석
- 시간 복잡도가 공간 복잡도보다 중요한 이유 
  - 시간도 적게 걸리고 자원 사용도 적은것이 좋은 알고리즘 풀이
  - 빅데이터 -> 공간 복잡도 주요 고려
  - 그외는 시간복잡도 주요 고려

#### 공간 복잡도(Space complexity) 
- 메모리 사용량을 측정을 통한 공간 분석 

#### 시간 복잡도(Time complexity) 
- 코드의 연산 횟수를 통한 속도를 분석 
- 시간 복잡도 표기법 
  - 빅오 : Worst case 연산
  - 빅오메가 : Best case 연산
  - 빅세타 : Average case의 연산  




<details>
<summary>알고리즘 작업중..</summary>
<div markdown="1">
수학 및 논리퍼즐
소수인지 판별하기(효율적인 개선점 찾기)
피보나치 수 구하기(Recursion 방법을 사용하지 않고 구현하기)
팩토리얼 구하기
문자열
역순으로 출력하기
가운데 글자 가져오기
애너그램 판단하기
정렬
검색
Binary search 구현하기
비트
2의 제곱수인지 판별한다.
두 수에서 다른 비트의 개수를 구한다. 
</div>
</details>
<br>


## 네트워크 
### 웹 동작 방식 
1. 사용자가 브라우저에 URL을 입력
2. 브라우저는 DNS를 통해 서버의 진짜 주소를 찾음
3. HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성함
4. TCP/IP 연결을 통해 HTTP요청이 서버로 전송됨 
5. 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메세지를 생성함 
6. TCP/IP 연결을 통해 요청한 컴퓨터로 전송 
7. 도착한 HTTP 응답 메세지는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력하여 사용자 확인












### 로드밸런싱 (L4/L7)
```
왜 로드밸런싱을 해야하는가? 
서버의 부하를 방지하기 위해 로드밸런싱 없이 스케일up, 스케일out을 고려해보면 
- scale-up : 서버의 하드웨어 사양을 늘린다. 서버의 하드웨어가 고사양을 올라갈수록 가격은 급격히 증가한다. 
- scale-out : 여러대의 서버를 놓아 부하를 할당하는 것을 생각하지만, 로드밸런스가 없다면 각 서버마다 다른 IP로 구성되며 각 서버에 고르게 동일한 기준으로 분배를 할수가 없다. 
```
#### L4
- IP, Port 기준으로 스케줄링 알고리즘을 통해 부하를 분산 
- 요청하는 서비스에 상관없이 서버로 요청하여 분배

#### L7
- IP, Port 외에도 HTTP(URI, Payload, Http Header, Cookie 등)의 내용을 기준으로 분산
- 콘텐츠 기반 스위칭


*나중에 AWS 추가 내용 보충*
https://jaehoney.tistory.com/73








### public vs private 
- Public Cloud : AWS, Azure, GCP와 같이 최종 사용자가 소유하지 않은 IT 인프라에서 생성되는 클라우드 환경
- Private Cloud : 단일 최종 사용자 또는 그룹의 전용 클라우드 환경 


### 클라우드 서비스 aaS : IaaS vs PaaS vs SaaS
- IaaS : 클라우드 서비스 제공업체가 인터넷 연결을 통해 인프라, 즉 실제 서버, 네트워크, 가상화, 데이터 스토리지를 고객을 위해 관리
        사용자가 운영 체제, 애플리케이션, 미들웨어 등을 관리하는 반면 제공업체는 모든 하드웨어, 네트워킹, 하드 드라이브, 데이터 스토리지 및 서버를 관리하며 가동 중단, 복구, 하드웨어 문제를 해결할 책임이 있다.
        - *내부 인프라팀에서 관리*
- PaaS : 외부 클라우드 서비스 제공업체가 하드웨어 및 애플리케이션-소프트웨어 플랫폼을 제공하고 관리하지만, 
        이 플랫폼에서 실행되는 애플리케이션 및 애플리케이션에서 사용하는 데이터는 사용자가 직접 처리하는 방식입니다.
        - *DevOps를 제공* 
- SaaS : 업체가 사용자를 대신해 소프트웨어 업데이트, 버그 수정, 기타 일반 소프트웨어 유지관리 작업을 수행하며 
        사용자는 대시보드 또는 API를 통해 클라우드 애플리케이션에 연결합니다.

참고 : https://www.redhat.com/ko/topics/cloud-computing/public-cloud-vs-private-cloud-and-hybrid-cloud







### Get 방식 vs. Post 방식
- GET : 요청하는 데이타가 HTTP Request Message의 Header 부분의 url이 담겨 전송 
  - url은 크기 제한이 존재
  - 보안이 필요한 데이터가 url로 그대로 노출
  - 서버의 값을 조회할 때 사용 
  - Caching rksmd 
- POST : HTTP Request Message의 Body 부분에 데이타가 담겨서 전송 
  - 서버의 값이나 상태를 변경 or 추가 하기 위해 사용

### Cookie vs. Session
- 저장 위치 : Cookie는 로컬 저장. Session은 서버 저장 
- 저장 형식 : Cookie는 Text, Session은 Object
- 만료 시점 : Cookie는 저장 시 설정, 세션은 브라우저 종료 시 삭제(기간 지정 가능) 
- Cookie는 로컬에 저장되므로 로드 속도는 빠르지만, 보안측면에서 안좋다
- Session은 서버에 저장되어 로드 속도는 느리지만, 보안측면에서는 유리하다






### 다중 서버 환경 세션 처리는?
- https://hyuntaeknote.tistory.com/6
  
#### Sticky Session 
- 세션을 최초에 생성된 서버로 요청을 고정. 로드밸런싱이 제대로 되지 않을 수 있다. 
- 한쪽으로 몰려 있고, 해당 서버 장애 시 모든 세션 정보를 잃는다. 

#### Session Clustering 
- 세션을 생성될 때마다 복제하여 각 서버의 세션정보를 일치시켜 정합성 이슈 해결 
- 매번 세션 객체를 복제하는 오버헤드가 발생 

#### 세션 스토리지 분리 방식 
- 세션 저장소를 별도 사용하여, 각 서버는 세션 스토리지에 대한 정보만 알고 있고 세션 저장소를 통해 공유






### Cache를 사용하는 이유는?
- 캐싱(Caching) : 이미 가져온 데이터나 결과값 복사본을 저장함으로써, 속도를 향상 시키며 동일한 데이터나 명령어에 반복해서 엑세스할때 유용하다 
  - 로컬 캐시 : 서버마다 따로 저장
  - 글로벌 캐시 : 여러 서버에서 캐시 서버를 참조. 네트워크 트래픽을 사용해야 해서 로컬 캐시보다는 느리다.  

### 브라우저 캐시
- 추후 정리 필요!!! 
- https://toss.tech/article/smart-web-service-cache





### WAS vs Web Server
- WAS (Web Application Server)
  - 동적 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버 (DB조회, 로직처리가 요구되는 컨텐츠)
  - 비지니스 로직을 넣을 수 있음 
  - Tomcat, PHP, ASP, .Net 
  * **JSP, servlet을 실행시킬 수 있는 소프트웨어 = 컨테이너**
   
- WS (Web Server)
  - 클라이언트가 서버에 페이지 요청을 하면 요청을 받아 정적 컨텐츠(.html, .png, .css등)를 제공하는 서버
  - 클라이언트의 요청을 기다리고 요청에 대한 데이터를 만들어서 응답하는 역할 (정적 데이터)
  - 정적 컨텐츠가 아닐 경우, WAS에게 전달한다
  - Nginx, Apache 







### TCP vs. UDP
> TCP는 신뢰성이 중요한 파일 교환, 데이터 교환 시 사용. 
> UDP는 실시간성이 중요한 스트리밍에 자주 사용
- TCP : 3-way handshaking 과정을 통해 연결을 설정
  - 신뢰성 높음. 속도가 비교적 느리다 
- UDP : 비연결형 서비스 
  - 신뢰성 낮음. 수신여부를 확인하지 않기 때문에 속도가 빠르다











### HTTP vs. HTTPS
> HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민번호 등을 주고 받으면 제3자에 의해 조회될 수 있습니다. 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다.
> HTTP는 TCP와 직접 통신, HTTPS는 SSL과 통신하고 SSL이 TCP와 통신

- HTTP (Hyper Text Transfer Protocal) : 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜. HTTP는 application level의 프로토콜로 TCP/IP 위에서 동작
  - 상태를 가지고 있지 않는 Stateless 프로토콜로 Method, Path, Version , Header, Body로 구성 
- HTTPS = HTTP + SSL(Secure Socket Layer), HTTP로 통신하는 소켓을 SSL or TSL(Transport Layer Security)라는 프로토콜로 대체한 것
  - 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템 사용, 공통키를 공개 키 암호화 방식으로 교환하고 이후 통신은 공통키 암호를 사용하는 방식
  - 키 교환 과정 
  1. 클라이언트(브라우저)가 서버로 최초 연결 시도를 함 
  2. 서버는 공개키(인증서)를 브라우저에게 넘겨줌 
  3. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급함 
  4. 브라우저는 세션키를 보관하며 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송
  5. 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻음
  6. 클라이언트와 서버는 동일한 세션키를 공유함으로써 데이터를 전달할 때 세션키로 암호화/복호하 진행함 
  *공개키로 암호화된 메세지는 개인키를 가지고 있어야만 복호화가 가능하기 때문에, 서버를 제외한 누구도 원본 데이타를 얻을 수 없다* 










### http1 과 http2의 차이
- HTTP1 연결당 하나의 요청/응답을 처리하여 비용적인 측면으로 헤더에 너무 많은 값을 담거나, 지연 현상 등이 발생
- HTTP2 HTTP1의 성능 문제를 해결한 버전
  - Multiplexed Streams : 하나의 커넥션으로 여러 개의 메세지를 동시에 주고 받을 수 있음. 
  - Stream Prioritization : 요청온 리소스간의 의존관계를 설정하여 먼저 응답해야하는 리소스를 우선 반환
  - Header Compression : 헤더 정보를 HPACK 압축 방식을 이용하여 압축 전송
  - Server Push : HTML 문서 상에 필요한 리소스를 클라이언트 요청없이 보내줄 수 있음.  









### Restful API
- REST(Representational State Transfer)ful API는 HTTP통신에서 어떤 자원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식
  - Resource(자원, URI)
  - Method(요청 방식, GET/POST/PUT/DELETE 등)
  - Representation of Resource(자원의 형태, JSON or XML 등)

#### REST API 6원칙 



#### HETEOS ? 






### 웹서버와 웹클라이언트의 차이
- 클라이언트는 서버에 컨텐츠 또는 서비스 기능을 요청합니다. 
- 서버는 클라이언트가 서비스를 요청할 때 클라이언트에 기능 또는 서비스를 제공합니다. 

### ARP vs RARP 
- ARP (Address Resolution Protocol) : IP 주소를 이용해 상대방의 MAC 주소를 알아오는 프로토콜이다.
  - ARP 요청: 특정 IP주소에 대해 MAC주소를 요구, MAC 주소를 알지 못하기 때문에 브로드 캐스트로 전송한다.
  - ARP 응답: 요청한 MAC 주소 정보를 유니캐스트(자신의 Mac주소 + 목적지 Mac주소 첨부하여 전송)로 전송한다.

- RARP (Reverse Address Resolution Protocol) : MAC 주소에 해당하는 IP 주소를 알아오는 프로토콜
  - RARP 요청: MAC정보를 담고있는 RARP 정보를 브로드 캐스트로 전송한다.
  - RARP 응답: 요청자의 IP 주소를 담은 RARP 응답을 유니캐스트로 전송한다.

- GARP (Gratuious ARP) : 송신 IP와 수신 IP가 동일한 ARP 요청
  - 자신의 존재를 알리는 목적으로 사용
  - IP 충돌 감지, ARP 테이블 갱신 용도로 사용





### Forward vs. Redirect
```
Forward는 페이지 전환 주체가 서버이고, 리다이렉트는 클라이언트 이다. 
클라이언트가 주체가 되어 페이지를 전환하는 방법은 접속한 URL이 아닌 다른 URL로 접속하는 방법 뿐이다. 
(redirect는 서버에서 이동할 다른 URL 주소를 내려준다.)
반대로 서버가 전환 주체가 되면 URL주소를 바뀌지 않고도 서버 내부의 동작을 통해 다른 응답을 내려줄수 있다. 
(외부에 공개되지 말아야할 경로 때문에 포워드를 쓴다. e.g. domain/95 -> domain/WEB-INF/95)
```



<details>
<summary>네트워크 작업중..</summary>
<div markdown="1">
OSI 7 계층
주요 프로토콜 포트
</div>
</details>
<br>


## Java 질문
### Java 
- 장점 - JVM을 통해 운영체제에 독립적, GC가 메모리 관리를 통한 편리함
- 단점 - JVM으로 인해 실행속도 느리다. 다중 상속이나 타입에 엄격하는 등 제약이 있다. 
- 특징 
  - 운영체제 독립적, 각 운영체제 마다 다른 JVM 설치 
  - 객체 지향 언어 (OOP)
  - 캡슐화, 상속, 다형성, 추상화
  - 객체 지향 설계 5원치(SOLID)
  - GC를 통한 자동 메모리 관리 
  - 동적 로딩 지원 
  - 멀티 쓰레드 직접 구현 

### Java8
- 함수형 프로그래밍을 위해  함수형 인터페이스와 람다와 함께 stream API가 추가 
- Null-safe한 작업을 위한 Optional API
- Date와 Time을 함께 처리하기 위한 LocalDateTime API 등이 추가






### Java7
- [ try-with-resources ]
try-with-resources란 Java7 버전에 추가된 기능으로, 리소스를 다 사용한 객체를 자동으로 반납(close)해줍니다. try-with-resources를 사용하면 코드가 try-finally보다 유연해지며, try-finally에서와 달리 누락없이 모든 자원을 반납할 수 있습니다.
try-with-resources를 통해 객체가 자동으로 반납되기 위해서는 AutoCloseable 인터페이스를 구현하고 있어야 합니다.


#### AutoCloseable
- try-with-resources에서 자동으로 close가 호출되는 것은 AutoCloseable을 구현한 객체에만 해당이 됩니다
```java
public interface AutoCloseable {
    void close() throws Exception;
}
```
- BufferedInputStream 객체는 InputStream 객체를 상속받습니다. 만약에 아래 코드와 같이 InputStream 객체가 AutoCloseable를 상속받은 Closeable을 구현하였을 때 BufferedInputStream 객체가 Try-with-resources에 의해서 해제될 수 있습니다.
  
```java
public abstract class InputStream extends Object implements Closeable {
    ...
}

public interface Closeable extends AutoCloseable {
    void close() throws IOException;
}
```







## OOP 객체 지향 
- 현실에 존재하는 사물을 있는 그대로 모델링하여, 행위와 속성을 정의하고 절차적이 아닌 객체가 중심이 되어 실제 사물이 동작하는 방식으로 설계하는 방식 
- 4대 특징 
  - 캡슐화 : 객체의 속성을 보호하기 위해서 사용 
    - 내부적 동작을 이해할 필요가 없이 단순 호출만으로 해당 기능을 실행할 수 있고 객체 단위 개발 가능 
  - 상속 
    - 하위로 내려갈수록 구체화 되는 것(구현)
    - 해당 클래스에서 필요한 속성 및 메서드를 정의하지 않고 상속을 받아서 사용
  - 다형성 
    - 하나의 객체를 여러개의 형태로 변환
    - Overriding(안에 로직이 다름), Overloading(변수가 다름) 
  - 추상화 
    - 공통의 속성, 기능을 묶어 정의 







### 절차지향 프로그래밍 vs 객체지향 프로그래밍 
- **절차지향은 데이터 중심, 객체지향은 기능 중심**
- 속도 부분에서는 절차지향이 강점을 가지고 있지만, 유지보수 및 실제 세계와 유사한 모델링으로 이해와 운영을 조금 더 쉽게 할 수 있다.
```
객체지향의 반대는 절차지향이 아니고 절차지향의 반대는 객체지향이 아닙니다. 위에서 설명한 것처럼 절차지향은 순차적으로 실행에 초점이 되어 있고 객체지향은 객체간의 관계/조직에 초점을 두고 있습니다. 이렇게 설명하면 객체지향은 절차적으로 실행되지 않냐? 라는 의문이 드는데 객체지향 역시 절차지향과 동일한 순서로 실행됩니다.
```
- 절차지향 프로그래밍 :  물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법
- 객체지향 프로그래밍 : 실제 세계를 모델링하여 소프트웨어를 개발하는 방법






### 객체 지향 설계 5원칙
- 좋은 소프트웨어 설계를 위해서는 결합도는 낮추고 응집도는 높여야 한다
  - 결합도
    - 모듈 간의 상호 의존 정도를 나타내는 지표
    - 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어서 객체의 재사용 및 유지보수가 유리함
  - 응집도
    - 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성
    - 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져, 재사용 및 유지보수가 용이
  
1. SRP( Single Responsibility Principle ) 단일 책임 원칙
어떠한 클래스를 변경해야 하는 이유는 한가지 뿐이어야 한다

2. OCP(Open Closed Principle) 개방 폐쇄 원칙
자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 함
상위 클래스 또는 인터페이스를 중간에 둠으로써, 자신은 변화에 대해서 폐쇄적이지만, 인터페이스는 외부의 변화에 대해서 확장을 개방해 줄 수 있다

3. LSP (리스코프 치환 원칙)
서브 타입은 언제나 자신의 기반(상위) 타입으로 교체할 수 있어야 한다

4. ISP(Interface Segregation Principle) 인터페이스 분리 원칙
클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다

5. DIP(Dependency Inversion Principle) 의존 역전 원칙
의존 관계를 맺을 때 변화하기 쉬운 것보다는 변화하기 어려운 것에 의존해야 한다










### Call By Value vs Call By Reference
- Call By Value
  - 인자로 받은 값을 복사하여 처리 
  - 받은 값을 변경해도 원래의 값이 보존된다
- Call By Reference
  - 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 주는 방식
  - 값을 복사하지 않고 직접 참고하기 때문에 속도가 빠르다 
  - 원래 값에 영향을 주는 리스크가 존재한다. 







#### 자바가 다중 상속을 지원하지 않는 이유
- Female, Male 클래스 모두 Human 클래스 walk 메소드를 상속받아 구현했다고 했을때, 우선순위에 대해 컴퓨터 입장에서는 해결방법이 없다. 








### 자바 인터페이스
- 추상 메서드와 상수만을 포함. interface 키워드를 사용하여 선언
  - 구현 객체의 같은 동작을 보장하기 위한 목적
  - 공통적으로 사용하는 방식이 필요하지만, 기능을 각각 구현할 필요가 있는 경우 사용
  - 모든 메소드는 추상메소드 이므로 abstract public 생략가능 
  - 상수는 public static final이며 생략 가능
  - 상속 관계 없이 관계를 맺을 수 있고 독립적인 프로그래밍이 가능해진다 
  - 자바 개발 협업 및 꼭 구현해야하는 것들을 표준화한 일종의 명세와 같은 것
  - Java8 default, static 메소드를 사용할 수 있어, 활용도가 더욱 높아짐









#### 인터페이스 vs. 추상클래스
```
- 인터페이스는 다중 상속 가능, 추상클래스는 단일 상속 가능 
- 추상 하위 클래스는 상위 추상 클래스를 구체화 시키는 것 
- 인터페이스를 구현한 클래스는 인터페이스에 정의된 기능을 제공한다는 것을 보장하는 것
```
- 추상클래스 : 추상 메소드를 가지고 있으며, abstract으로 선언된 클래스 
  - 여러 클래스의 공통된 부분을 추상화, 메소드의 동작을 하위 클래스에 위임
  - Java8 이전까지는 인터페이스를 신규 메소드 추가 하는 것이 risk가 있어
    추상클래스에 신규 메소드를 구현하여 사용하였다. 
  (인터페이스 구현된 모든 클래스 수동으로 추가 구현해야했으므로) 







### Java 동작과정 
1. Java 소스 파일 javac로 컴파일하여 class 파일(Java 바이트 코드) 생성
   (javac 컴파일러, 코드 분석 처리, 플랫폼에 independent 독립적이다)
2. 클래스 로더가 컴파일 된 Java 바이트 코드를 런타임 데이터 영역으로 로드
   (여기부터 JVM 영역 자바 바이트 코드를 OS 어셈블리에 맞는 목적 코드로 생성. 운영체마다 JVM은 다르게 동작할수 있다) 
3. 실행 엔진이 자바 바이트 코드를 실행함 


### Java 메모리 구조 
- 코드 영역 : 실행할 프로그램의 코드가 저장되는 영역 
- 데이터 영역 : 프로그램의 전역 변수(global), 정적 변수(static)가 저장되는 영역 
  - 프로그램 시작과 함께 할당되며 종료시 소멸
- 힙 영역 : 동적할당 영역. GC가 자동으로 해제해주고, 스택영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당 
- 스택 영역 : 함수의 호출과 함께 할당되며, 지역변수, 매개변수 저장 
  - 저장되는 함수의 호출 정보를 스택 프레임이라 한다. 
  - 함수의 호출이 완료되면 소멸 
  - 높은 주소 -> 낮은 주소로 메모리가 할당





### JVM
#### Runtime Data Area
- Method Area(메소드 영역) : 클래스 변수 이름, 타입, 접근 제어자 등 클래스 정보 저장
                          (static 변수, 인터페이스 등도 저장) 
- Heap Area(힙 영역) : new를 통해 생성된 객체와 배열 인스턴스 저장. GC는 힙 영역을 청소하며 메모리 확보 
  - JAVA 메모리 상수풀
    - Heap 내의 Permanent Area(고정 영역)에 생성되어 프로세스 종료까지 유지
    - 상수에 대해 먼저 검색 후 없으면 상수풀에 신규 추가
    - 메모리 절약 효과
- Stack Area(스택 영역) : 메소드가 실행되면 스택 영역에 할당 지역변수, 매개변수, 리턴값 등 저장
- PC register(PC 레지스터) : 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장한다. 
    - Program Counter : 컴파일된 바이트 코드의 몇번째 row를 실행하는 알려줌 
- Native Method Stack(네이티브 메소드 스택) : 자바 외의 언어 (C/C++ 등) JVM 성능 향상을 목적으로 한 코드를 위한 메모리 영역. JNI를 통해 사용된다 
















### 가비지 컬렉터
*mark and sweep*
- 더 이상 참조되지 않는 메모리를 청소해주는 JVM의 실행 엔진의 한 요소
  - Heap 영역을 탐색하여 메모리 정리
- 가비지 컬렉션 과정 
  1. 메모리 사용을 중단 stop-the-wrold 먼저 실행 
  2. GC에서 실행하는 쓰레드를 제외한 모든 쓰레드가 작업을 멈춘다. 
   
  - Young Generation - Minor GC
    - Young 영역 : 새롭게 생성된 객체들 위치 대부분 금방 접근 불가능 상태가 되기 때문에 많은 객체가 생성되었다 사라진다.
      - 1개의 Eden/ 2개 Survivor로 구성
      - 새로운 객체 Eden에 생성 -> GC(Minor) 동작 -> 살아 남은 객체 Survivor0 이동
        if(Survivor0 == full) -> GC(Minor) 동작 -> 살아 남은 객체 Survivor1 이동 
        (2개 Survivor 중 1개는 꼭 비워져 있어야 함)
        *-> 이 동작들이 반복되어 특정 횟수만큼 살아남은 객체는 Old 영역으로 이동* 
  - Old Generation - Major GC
    - Old 영역 : Young 영역에서 계쏙 사용되어 살아남은 객체가 복사되는 영역. Young 영역보다 크게 할당되며 더 적은 GC가 발생한다. 
    -> Old 영역이 가득차서 Survivor 영역에서 Promotion이 불가능할 때, Old 영역에 대한 GC(Major GC)가 실행 
- **GC 성능 높이기** 
  - Collection 등을 활용할 때, 사용할 객체의 크기를 명시
  - Stream을 바로 사용
  - 불변(Immutable) 객체 사용
    - mutable 객체는 계속 다른 값을 참조하여 생존하며 Old영역으로 이동하게 된다. Old영역에서도 참조하는 객체가 바뀌기 때문에 GC가 검사해야하는 범위가 늘어난다. 
    - immutable은 객체는 기존에 이미 존재하는 값을 참조하기 때문에 young까지 GC 검사를 진행하지 않아도 되고 scan 범위를 줄일 수 있다.
  - 설정 변경
    - 애플리케이션을 중단시킨 후에 GC를 병렬로 동시에 진행시키는 것
    - 애플리케이션과 GC작업을 동시에(concurrent) 진행시키는 것
 









### Parameter vs Argument 
- Parameter : 함수를 선언할 때 사용된 변수 
- Argument : 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값 







### 컬렉션 프레임워크 (Collections Framework)
- 데이터 군(컬렉션)을 저장하는 클래스들을 표준화한 설계 
  - 프레임워크 : 표준화된 프로그래밍 방식

- 컬렉션 프레임워크의 핵심 인터페이스
  - List 인터페이스 : 순서가 있는 데이터 집합, 중복 허용 
    *- 중복을 허용하면서 저장 순서가 유지되는 컬렉션을 구현하는데 사용* 
    - 구현 클래스 : ArrayList, LinkedList, Stack, Vector 등


  - Set 인터페이스 : 순서를 유지하지 않고, 데이터 중복을 허용하지 않는 데이터 집합
    - 구현 클래스 : HashSet, TreeSet 등


  - Map 인터페이스 : key, value를 한 쌍(Pair)로 이루어진 데이터 집합 
    - 순서유지 X, 키는 중복 허용 X, 값은 중복 허용 


  - Map.Entry 인터페이스 : Map 인터페이스의 내부 인터페이스 
    - key, value를 다루기 위해 내부적으로 entry 인터페이스 정의


  - HashSet 인터페이스 : Set 인터페이스 구현한 대표적 컬렉션 
    - 중복요소 저장 X, 저장순서 유지하고자 하면 LinkedHashSet 사용


  - TreeMap 인터페이스 : 이진 검색 트리의 형태로 key,value로 데이타 저장 
    - HashMap이 검색에 관한 대부분 뛰어나지만, **범위 검색**이나 정렬이 필요한 경우 사용


  - Properties : 애플리케이션의 환경설정 과 관련된 속성을 저장하는데 사용, 읽고 쓰는 편리한 기능을 제공 


  - Collections : 컬렉션과 관련된 메소드 제공 
    - 컬렉션의 동기화 
      - 멀티 스레드 프로그래밍에서는 데이터의 일관성을 유지하기 위해 공유되는 객체에 동기화가 필요
      ```java
        static Collection synchronizedCollection(Collection c){}
        static List synchronizedList(List list){}
        static Set synchronizedList(Set set){}
        static Map synchronizedList(Map map){}
      ```
    - 변경불가 컬렉션 만들기
      - 읽기전용 컬렉션으로 만든다. 주로 멀티 스레드 환경에서 컬렉션 공유 방지하기 위해 사용
      ```java
        static Collection unmodifiableCollection(Collection c){}
        static List unmodifiableList(List list){}
        static Set unmodifiableList(Set set){}
        static Map unmodifiableList(Map map){}
      ```
    - 싱글톤 컬렉션 만들기
      - 인스턴스 개수 생성 제한
      ```java
        static List singletonList(List list){}
        static Set singletonList(Set set){}
        static Map singletonList(Map map){}
      ```
    -  한 종류의 객체만 저장하는 컬렉션 만들기
      - 지정된 종류의 객체만 저장할 수 있도록 제한
      ```java
        static Collection checkedCollection(Collection c, Class type){}
        static List checkedList(List list, Class type){}
        static Set checkedList(Set set, Class type){}
        static Map checkedList(Map map, Class type){}
      ```

### 오버로딩(Overloading) vs. 오버라이딩(Overriding)
- 오버로딩 : 매개변수의 타입과 개수를 변경하면서 동일명칭 메소드를 여러 개사용 
- 오버라이딩 : 상위 클래스가 가지고 잇는 메소드를 하위 클래스에서 재정의하여 사용
  -> 다형성을 만든다.  





### boxing vs unboxing 
> Wrapper 클래스 : 기본자료형을 객체로 다루기 위해 사용하는 클래스
- 박싱 : 기본 자료형(primitive) 데이터를 래퍼(Wrapper) 객체로 변환
- 언박싱 : 래퍼(Wrapper) 클래스의 데이터를 기본 자료형(primitive)으로 만드는 과정
- 오토박싱 : 해당 래퍼 클래스에 기본 자료형의 데이터를 대입하면 자동 박싱 = 오토 박싱 
- 오토언박싱 : 기본 자료형에 래퍼 클래스 객체를 대입하면 자동 언방식 
```java
Integer.parseInt("100"); // 문자열 -> 기본 자료형 
Integer.valueOf("100"); // 문자열 -> Wrapper 클래스 

Integer i = new Integer(10); 
Integer i = 10; //오토박싱(autoboxing)
int i1 = i.intValue();             
int i1 = i; //언박싱(unboxing)
```






### 객체 vs. 클래스
- 클래스 : 객체를 만들어 내기 위한 설계도
  - 객체의 속성과 행위를 정의한 것 
- 객체 : 소프트웨어로 구현할 대상
  - 메모리에 할당된 실체화된 인스턴스
- 인스턴스 : 객체를 소프트웨어로 구현한 것 
  





### super vs. this
- this : 현재 클래스 참조 
- super : 부모 클래스 참조



### fianl 키워드란?
- final 클래스 
  - 다른 클래스에서 확장해서 쓸수 없다 (= 상속 받을 수 없다)
  - 더 이상 확장해서는 안되는 클래스에 사용 
  - 해당 클래스를 상속받아 내용을 변경하는 것을 방지
- final 메소드 
  - 해당 메소드를 Overriding 할 수 없다. 
- final 변수 
  - 그 변수의 값을 바꿀 수 없다. 
  - 변수 생성과 동시에 값을 초기화 해야한다.
- final 래퍼런스 변수 
```java
public class DangerousStates {
  private final String[] states = new String[] { "Alabama", "Alaska", ... };
 
  public String[] getStates() { 
    return states;
  }
}
 
 
// Immutable -- returns an unmodifiable List instead
public class SafeStates {
  // 객체 자체를 immutable 하도록 하기 위해서는 
  // String 배열을 private로 막아 놓고 외부에서 접근시 AbstractList를 통해 값을 접근 하도록 해야 한다.
  private final String[] states = new String[] { "Alabama", "Alaska", ... };
  private final List statesAsList = new AbstractList() {
        public Object get(int n) { 
          return states[n];
        }
 
        public int size() {
          return states.length;
        }
      };
         
  public List getStates() {
    return statesAsList;
  }
}​
```






### Java String vs StringBuffer vs StringBuilder
- String : 새로운 값을 할당할 때마다 새롭개 객체 생성 (불변 객체이므로 값을 바꿀수 없음)
           Heap에 계속 쌓이고 GC가 처리해줌
- StringBuffer : 멀티쓰레드 환경에서 사용 가능.동기화 지원, 속도가 느리지만 병렬 상황에서 안전 
  - mutable, 할당 된 주소가 안바뀌고 안의 데이타만 바꿀 수 있어. 지속적으로 GC의 관리대상 
- StringBuilder : 단일쓰레드 환경에서 사용. 동기화 지원 X, 속도는 빠르지만 병렬 상황에서 안전하지 않다. 
  - mutable, StringBuffer와 동일










### Static vs non-Static
#### Static
- static 멤버는 클래스 당 하나만 생성
- 동일한 클래스의 모든 객체들에 의해 공유
- 객체 내부가 아닌 별도의 공간에서 생성(메소드 영역)
- 객체를 만들기 전에도 사용가능, 객체가 사라지지 않음. 프로그램이 종료될때 모두 사라진다.
- 스태틱 초기화 블럭은 클래스가 메모리로 올라갈때 (거의 프로그램 시작, 클래스 로딩시) 딱 한번 실행
#### non-Static
- 객체 마다 별도로 존재한다. 
- 객체 내에 각각 공간을 유지
- 객체와 같이 스택영역에 생성 
- 객체가 생길 때 생성 
- 객체가 생성해야 사용할 수 있다. 







### == 와 Equals() 메서드의 차이
- 기본형인 경우 == 로 비교할 수 있지만, 레퍼런스 변수인 경우 == 은 값 비교가 아니라 참조주소를 비교하는 행위이므로 equals를 사용해야 한다. 
- *예외적으로 Wrapper 클래스는 기본자료형과 비교 == 로 가능. -> 컴파일러가 자동적으로 오토박싱/언박싱 처리해주기 때문*






### 제네릭(Generic) 이유와 사용법
- 제네릭 : 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 당시 타입 체크를 해주는 기능 
  - 객체 타입을 컴파일 타임에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거러움을 줄임
  - 박싱/언박싱 등 타입체크와 형변환 생략을 통해 코드가 간결해 진다. 










### 예외, 오류 
- 오류 (Error) :  시스템 비정상적인 상황 발생, 개발자가 미리 예측하기 어려움 
  - Stack Overflow, outofmemoryerror 등 
- 예외 (Exception) : 개발자가 구현한 로직에서 발생 
  - 발생할 상황을 미리 예측하여 처리 








### checked Exception vs unChecked Exception 
- checked Exception : 컴파일 단계에서 발생 
  - 예외 발생 트랜잭션 처리 시 롤백하지 않아도 됨 
- unchecked Exception : 런타임 단계에서 발생 
  - 반드시 예외처리를 해야 하는 것은 아님. 
  - 예외 발생 트랜잭션 처리 시 롤백으르 해야한다. 







### 일급 객체 (first class citizen)
1. 변수나 데이타에 할당할 수 있다. 
2. 객체의 인자로 넘길 수 있다. 
  - 자바는 객체를 인자로 넘길 수 없다. 
  ```java
    fun function(f: () -> Unit) {
       f.invoke()
    }

    val test: () -> Unit = { println("kotlin") }
  ```
3. 객체의 리턴값으로 리턴할 수 있다. 







### 함수형 프로그래밍 (Functional Interface)
- immutable(불변) data와 first class citizen으로서 함수
- 하나의 추상 메소드를 가지고 있는 인터페이스 
- staic 메소드나 default 메소드는 개수에는 제약이 없음 
```
// 사용이유 
java에서 함수를 일급객체처럼 다룰 수 있게 하기 위함 
람다식을 사용하게 만드는 배경
```






### 람다식
> 람다 표현식 = 익명 클래스 
- 특정 메소드의 사용을 위해서 일회용 객체를 만들지 않아도 됨으로 성능면에서 좋다 
```java
new Thread(()->{
    System.out.println("람다 표현식을 사용한 일회용 스레드 생성");
}).start();
```






### Stream API 
- 배열/컬렉션 등의 데이타를 처리하기 위한 API, 멀티 쓰레드를 활용해서 병렬로 연산을 수행할 수 있고, 내부 반복으로 연산을 수행하기 때문에 코드가 매우 간단해진다. 
```java
public static String streamTest() {
    String result = Stream.of("TONY", "a", "hULK", "B", "america", "X", "nebula", "Korea")
            .filter(w -> w.length() > 1)
            .map(String::toUpperCase)
            .map(w -> w.substring(0, 1))
            .collect(Collectors.joining(" "));

    return result;
}
```







### 리플렉션
> 실행 시간에 다른 클래스를 동적으로 로딩하여 접을 때, 클래스와 멤버 필드 그리고 메서드 등에 관한 정보를 얻어야 할 때 
> 리플렉션 없이도 완성도 높은 코드를 구현할 수 잇지만 사용한다면 조금 더 유연한 코드를 만들수 있다. 
- 자바에서 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적으로 로딩하며 생성자, 멈버필드 그리고 멈버 메서 등을 사용할 수 있는 기법 
- 클래스 패키지 정보, 접근 지정자, 슈퍼클래스, 이노테이션 
- 컴파일 시간(Compile Time)이 아니라 실행 시간(Run Time)에 동적으로 특정 클래스의 정보를 객체화를 통해 분석 및 추출해낼 수 있는 프로그래밍 기법이다.
- Reflection을 사용하는 기술, 스프링 프레임워크, 대표적 ORM 기술인 하이버네이트, jackson라이브러리 등
- Reflection을 사용해서 스프링에서는 런타임 시에 개발자가 등록한 빈을 애플리케이션에서 가져와 사용할 수 있게 되는 것






### 자바 스레드 구현
#### Thread Pool
- 쓰레드를 미리 만들어 놓고 작업을 할당 (ExcutorService 이용해서 할당할 수 있음..?^^) 
  - 생성/수거에 드는 비용을 무시할 수 없음 
  - 많으면 메모리 낭비, 노는 쓰레드 있을 수 있음 
  - 프로그램 성능 저하 방지






### Volatile, Synchronized
다시 공부!! 
- https://jronin.tistory.com/110
  
- volatile
멀티 코어 프로세서에서는 코어마다 별도의 캐시를 가지고 있음. 코어는 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 읽어서 작업하게 됨. 다시 같은 값을 읽어올 때는 먼저 캐시에 있는지 확인하고 없을 때만 메모리에서 읽어온다

volatile을 사용하게 되면 캐시를 들르지 않고 메모리에서 값을 읽어와서 **캐시와 메모리간의 값의 불일치가 해결됨**. 싱글턴 패턴에 스레드 세이프를 주기 위해 인스턴스에 volatile을 준다

- synchronized
특정 영역을 임계 영역으로 지정하는 키워드, 임계 영역은 멀티 스레드 프로그램의 성능을 좌우하기 때문에 가능하면 메서드 전체에 락을 거는 것 보다는 synchronized 블럭으로 임계영역을 최소화하는 것이 좋음

```java
class MyClass {
  // 캐시, 메모리 간에 불일치 방지
  public static volatile MyClass instance;
  public staitc MyClass getInstance() {
    MyClass ref = instance;
    if (ref == null) {
      // instance가 아직 생성 안되었을때만, 임계영역, MyClass만 lock! 
      synchronized(MyClass.class) {
        if (instance == null) {
          ref = instance = new MyClass();
        }
      }
    }
    return ref;
  }
}
```
출처: https://bestugi.tistory.com/19 [Question Mark:티스토리]





### JDBC Statement vs PrepareStatement
> 캐시 사용여부의 차이 
> statement 준비(구문 준비) -> 컴파일(최적화 변환) -> 실행(값 바인드) 
- JDBC : 데이타베이스에 연결 및 작업하기를 위한 JAVA의 표준 인터페이스
- Statement
  - 단일로 사용될 때 빠른 속도를 지닙니다.
  - 쿼리에 인자를 부여할 수 없습니다.
  - 매번 컴파일을 수행해야 합니다.

- PreparedStatement
  - 쿼리에 인자를 부여할 수 있습니다.
  - 처음 프리컴파일 된 후, 이후에는 컴파일을 수행하지 않습니다.(기존 객체 재사용)
  - 여러번 수행될 때 빠른 속도를 지닙니다. (캐싱 처리)





### 직렬화(Serialization)
> redis 캐시 적재할때 사용하였음. 데이터+객체를 직렬화하여 캐시에 담음
> 상품 프로젝트에서 캐시를 적재하고, 외부 프로젝트에서 해당 UID를 가지고 역질렬화 하여 확인  
- 객체 또는 데이터를 외부의 자바 시스템에서도 사용할수 있도록 바이트 형태로 데이터 변환하는 기술
- (역질렬화) 바이트로 변환된 데이터를 다시 객체로 변환하는 기술 
- SerialVersionUID 선언 이유
  - 직열화, 역직렬화시 버젼번호 채번, 클래스(코드)가 변경되는 것을 확인하기 위해
  - SericalVersionUID가 다르면 InvalidClassException이 발생할 수 있다.
```
// 직렬화할 클래스
public class Member implements Serializable{
  ...
}
```







### equals vs hashcode 
```
동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로, 동일한 객체는 동일한 해시코드를 가져야 한다. 그렇기 때문에 만약 우리가 equals() 메소드를 오버라이드 한다면, hashCode() 메소드도 오버라이드 되어야 한다.
```
*다른 객체에 대해 동일한 hashCode를 생성한다면 hashTable을 생성하는데 불이익을 받을 수 있음을 인지*

- equals : boolean equals(Object obj)로 정의된 equals 메소드는 2개의 객체가 동일한지 검사하기 위해 사용된다. 
  - 2개의 객체가 가리키는 곳이 동일한 메모리 주소일 경우에만 동일한 객체가 된다.
- hashcode : int hashCode()로 정의된 hashCode 메소드는 실행 중에(Runtime) 객체의 유일한 integer값을 반환한다. 
  - Object 클래스에서는 heap에 저장된 객체의 메모리 주소를 반환하도록 되어있다

참고 : https://mangkyu.tistory.com/101
- https://jisooo.tistory.com/entry/java-hashcode%EC%99%80-equals-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C




## Spring Framework 
자바(JAVA) 엔터프라이즈 개발을 위한 "오픈소스(Open Source)" 애플리케이션 프레임워크(Framework)
- 경걍 컨테이너로서 자바 객체를 직접 관리
- POJO 방식의 프레임워크
  - 객체 지향적인 원리에 충실하면서 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트
    - 특정 규약에 종속되지 않는다.
    - 특정 환경에 종속되지 않는다.
    - 객체 지향적 원리에 충실해야한다.
  - 클래스 간의 결합도가 낮아져 다른 솔루션으로 변경하고자 할 경우 @JmsListener를 다른 솔루션으로 코드를 수정하면 가능
    유지보수에 더 유용하다
```java
@Component
public class ExampleListener {

  @JmsListener(destination = "myDestination")
  public void processOrder(String message) {
    System.out.println(message);
  }
}
```

참고 : https://doing7.tistory.com/81




참고 스프링 프레임워크 핵심 : *https://mangkyu.tistory.com/150* 
###  DI(Dependency Injection)
- 기존처럼 개발코드 부분에서 객체를 생성하지 않고, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 패곹리에 해당 하는 별도의 공간에서 객체를 생성하고 데이터 간의 의존성을 주입해 개발코드에서는 이를 가져다씀으로서 의존성을 줄이는 방식
- 객체가 직접 의존하고 있는 객체를 생성하거나 검색할 필요가 없어지므로 코드의 관리가 쉬워짐
- 생성자를 통해 의존성 주입을 가장 추천











### DL(Dependency Look-up)
- 






### IoC(Inversion of Control)
- 직접 제어야하는 부분에 대한 권한을 프레임워크 등에 넘기는 기술
- 인스턴스의 생성부터 소멸까지 개발자가 아닌 컨테이너가 대신 관리해주는 것
 









### AOP(Aspect Oriented Programming) 
- 기존의 OOP에서 기능별로 클래스를 분리했지만 여전히 로깅, 트랜잭션, 보안, 자원 해제, 성능 테스트 등 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식
- 개발 코드에서는 비즈니스 로직에 집중하고 실행시에 비즈니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로서 중복코드를 줄일 수 있는 방식











### DAO(Data Access Object)
- DB에 접근하여 실제 데이터를 조회 또는 조작하는 클래스, Repository 또는 Mapper에 해당함




### BO(Business Object)
- 여러 DAO를 활용해 비지니스 로직을 처리하는 클래스, Service에 해당함




### DTO(Data Transfer Object):
- 데이터를 주고 받기 위해 사용하는 클래스




### VO(Value Object)
- 실제 데이터만을 저장하는 클래스




### Spring에서의 싱글톤 패턴
- 인스턴스가 절대적으로 1개만 존재한다는 것을 보증하고 싶은 경우
- 동일한 인스턴스를 자주 생성해주어야 하는 경우(메모리 낭비의 방지)
  ```java
  public class Person {
    private static Person instance;
    
    public static Person getInstance() {
        if(instance == null){
            instance = new Person();
        }
        return instance;
    }
  }
  ```








### Spring MVC
- 웹 어플리케이션 개발을 위한 MVC 패턴 기반의 웹 프레임워크 
  #### MVC 패턴
  - Model : 데이터를 저장하는 컴포넌트 
  - View : 사용자 인터페이스(UI) 컴포넌트
  - Controller : 사용자의 요청을 처리하고 Model과 View를 중개하는 컴포넌트
- Dispatcher Servlet : 클라이언트 요청을 먼저 받아들이는 서블릿, 요청에 맞는 컨트롤러에 전달
- Handler Mapping : 해당 요청이 어떤 컨트롤러에게 온건지 확인 
- Controller : 요청을 받아 처리하여 결과를 디스패처 서블릿에게 전달
- ViewResolver : View의 이름을 통해 알맞은 View를 찾음 
- View : 사용자에게 보여질 UI 화면












#### Spring MVC의 장점과 단점 그리고 SpringBoot
- 장점 
  - 의존건 주입을 통해 컴포넌트 간의 결합도를 낮출수 있어 단위테스트 용이
  - 제어의 역전을 통해 빈(객체)의 라이프싸이클에 관혀하지 않고 개발에 집중 
- 단점
  - XML 기반으로 하는 프로젝트 설정에 비용이 듬(시간)
  - 톰캣과 같은 WAS를 별도로 설치

##### 해결책 (Spring Boot)
- 자주 사용되는 라이브러리들의 버전 관리 자동화 
- AutoConfig로 복잡한 설정 자동화 
- Tomcat과 같은 웹서버 제공
- 실행 가능한 Jar로 개발 가능 








##### Spring 어노테이션
@Bean: 개발자가 직접 제어가 불가능한 외부 라이브러리 또는 설정을 위한 클래스를 수동으로 빈 등록할 때 사용 (기존 xml로 빈등록..)
@Configuration: 1개 이상의 @Bean 메소드를 갖는 클래스의 경우에 반드시 명시해 주어야 함
@Component: 개발자가 직접 개발한 클래스를 컴포넌트 스캔 방식으로 자동으로 빈 등록할 때 사용

@SpringBootApplication : 
- @SpringBootConfiguration: @Configuration을 포함하고 있으며, 테스트 등을 위한 자동 설정을 위한 하기 위해 찾아짐
- @EnableAutoConfiguration: 필요한 설정들을 자동으로 해주는 자동 설정 기능을 활성화함
- @ComponentScan: 빈을 찾아서 등록하기 위한 위치를 지정함










### Spring MVC - 쓰레드 로컬(Thread Local)
- 각 쓰레드에 할당되는 저장 공간인데, 스프링과 같은 멀티 쓰레드 프로그래밍 환경에서 쓰레드 로컬에 값을 저장하고 해제하지 않으면 문제가 발생한다. -> 쓰레드가 재사용되기 때문이다. 
- Spring Security에서 사용되는 SecurityContextHolder는 ThreadLocal을 사용









### 필터 vs 인터셉터 vs AOP
> 공통부분을 빼서 따로 관리한다는 측면은 같다
- 필터
  - 서블릿 필터는 **DispatcherServlet 이전**에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러가지 체크를 수행할 수 있다.
- 인터셉터
  - 필터는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다.
  - 인터셉터는 스프링의 **DistpatcherServlet이 컨트롤러를 호출하기 전, 후**로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대해 처리한다.
  - 로그인체크, 권한 체크
- AOP
  - Interceptor나 Filter와는 달리 메소드 전후의 지점에 자유롭게 설정이 가능하다.
  - 객체 지향의 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다.



















### Maven vs Gradle
빌드 관리 툴이란? 프로그래밍 개발이 발전됨에 따라 필요한 라이브러리들은 점점 많아지고, 이들을 일일이 관리하기에는 어려움이 따릅니다. 그래서 만들어 진것이 빌드 관리 툴! 소스 코드를








### Framework vs. Library
- 라이브러리: **사용자**가 흐름에 대한 제어를 하며 필요한 상황에 가져다가 쓸 수 있다. 
- 프레임워크: 전체적인 흐름을 자체적으로 제어한다.

- 프레임워크와 라이브러리는 실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라집니다. 프레임워크를 사용하면 사용자가 관리해야 하는 부분을 프레임워크에 넘김으로써 신경써야 할 것을 줄이는 제어의 역전(IoC, Inversion Of Control)이 적용됩니다.










### 스프링의 장점
- https://joychae.tistory.com/27
- POJO 





- DI





- AOP





- WAS 독립적인 개발 환경 







### application context에 대해서 설명하시오




### 빈(Bean)





### 빈팩토리(Bean Factory)




### 스프링 컨테이너




### Scope(스코프)란?





### 오토와이어링이란 무엇인가?





### 스프링 환경설정 혼자 잡을 수 있는가? 대강 어떻게 해야하는지 설명해 보시오.




## 프로그래밍 

### 메세지 큐(Message Queue)란
메세지 큐(Message Queue)란 Queue 자료구조를 이용하여 데이터(메세지)를 관리하는 시스템으로, 비동기 통신 프로토콜을 제공하여 메세지를 빠르게 주고 받을 수 있게 해준다. 
- Producer(생산자)가 Message를 Queue에 넣는다
- Consumer가 Message를 가져와 처리
- Kafka, Rabbit MQ, AMPQ 등이 있다.













### Docker(도커)와 Kubernates(쿠버네티스)
프로세스를 격리시킨 컨테이너를 통해 가상화를 하는 Docker(도커)와 같은 기술들이 등장하게 되었고, 도커를 통해 구동되는 컨테이너를 관리하기 위한 Kubernates(쿠버네티스)가 등장









### TDD(Test-Driven Development)
- 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스로, 개발자는 우선 요구되는 기능에 대한 테스트케이스를 작성하고, 그에 맞는 코드를 작성하여 테스트를 통과한 후에 상황에 맞게 리팩토링하는 테스트 주도 개발 방식을 의미합니다.
- 개발자는 테스트를 작성하기 위해 해당 기능의 요구사항을 확실히 이해해야 하기 때문에 개발 전에 요구사항에 집중할 수 있도록 도와주지만 테스트를 위한 진입 장벽과 작성해야 하는 코드의 증가는 단점으로 뽑힙니다.













### DDD(Domain-Driven Design)
- DDD(Domain-Driven Design)는 실세계에서 사건이 발생하는 집합인 Domain(도메인)을 중심으로 설계하는 방법입니다. 옷 쇼핑몰을 예로 들면 손님들이 주문하는 도메인, 점주들이 관리하는 도메인 등이 있을 수 있습니다. 이러한 도메인들이 서로 상호작용하며 설계하는 것이 도메인 주도 설계입니다. 도메인 주도 설계에서 도메인은 각각 분리되어 있는데, 이러한 관점에서 MSA(MicroService Architecture)를 적용하면 용이한 설계를 할 수 있다. DDD에서는 같은 객체들이 존재할 수 있는데, 예를 들어 옷 구매자의 입장에서는 (name, price)와 같은 객체 정보를 담지만, 판매자의 입장에서는(madeTie, size, madeCountry) 등이 있을 수 있습니다. 즉, 문맥에 따라 객체의 역할이 바뀔 수 있는 것이 DDD입니다.








### MSA
MSA(Microservice Architecture)는 모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 Monolithic Architecture(모놀리식 아키텍쳐)의 한계점을 극복하고자 등장하게 되었습니다. MSA는 1개의 시스템을 독립접으로 배포가능한 각각의 서비스로 분할합니다. 각각의 서비스는 API를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성합니다. 

장점
- 일부 서비스에 장애가 발생하여도 전체 서비스에 장애가 발생하지 않는다.
- 각각의 서비스들은 서로 다른 언어와 프레임워크로 구성될 수 있다.
- 서비스의 확장이 용이하다.


단점
- 서비스가 분리되어 있어, 테스팅이나 트랜잭션 처리 등이 어렵다.
- 서비스 간에 API로 통신하기 때문에 그에 대한 비용이 발생한다.
- 서비스 간의 호출이 연속적이기 때문에 디버깅 및 에러 트레이싱이 어렵다.

참고 
https://helloworld.kurly.com/blog/ddd-msa-service-development/


### 리팩토링 
참고 
https://helloworld.kurly.com/blog/rms-refactoring/


















## Database 
### 인덱스(index)
- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
- 부등호(<, >)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하다.




### 트랜잭션(Transaction)
- 트랜잭션이란 데이터베이스 작업의 단위로써 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법입니다.







### RDBMS
- 2차원의 행과 열로 데이터의 관계를 관리하는 데이터베이스 
장점: 스키마에 맞추어 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
단점: 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며, 수평적 확장이 어렵다.







### NoSQL
- RDBMS가 비대해짐에 따라 관계가 복잡해져, 이를 극복하기 위해 등장하게 된 데이터베이스
장점: NOSQL은 스키마 없이 Key-Value 형태로 데이터를 관리하여 좀 더 자유롭게 데이터를 관리할 수 있다.
단점: 중복된 데이터가 추가 가능하여, 이에 대한 관리가 필요하다.










## 디자인 패턴 
자주 사용하는 설계 패턴을 정형화 해서 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계
알고리즘과 유사하지만, 명확하게 정답이 있는 형태는 아니며, 프로젝트의 상황에 맞추어 적용 가능

- 생성 패턴 
  - 객체를 생성하는 것과 관련된 패턴으로, 객체의 생성과 변경이 전체 시스템에 미치는 영향을 최소화 하고, 코드의 유연성을 높여준다
  - Factory Method
  - Singleton
    - Singleton 패턴은 어떠한 클래스가 유일하게 1개만 존재할 때 사용함
  - Prototype
  - Builder
  - Abstract Factory

### Factory Method









### Singleton






### Prototype







### Builder








- 구조 패턴
  - 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램 구조를 설계하는데 활용될 수 있는 패턴
  - 클래스, 객체들의 구성을 통해서 더 큰 구조를 만들 수 있게 해준다
    - Adapter
    - Composite
    - Bridge
    - Decorator
    - Facade
    - Proxy

### Adapter







### Decorator







### Proxy








- 행위 패턴
- 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로, 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 제공함
  - Template Method
  - Interpreter
  - Iterator
  - Observer
    - 관찰자 패턴은 변화가 일어났을 때, 미리 등록된 다른 클래스에 통보해주는 패턴을 구현한 것
    - Event listener에서 이런 패턴을 사용하고 있음
  - Strategy


### Template Method










### Iterator









### Observer







### Strategy











참고자료 
출처: https://raisonde.tistory.com/entry/Deadlock의-발생-조건과-해결법 [지식잡식:티스토리]
출처: https://jusungpark.tistory.com/17 [정리정리정리:티스토리]

