< 기술 스택 관련 >
시스템 흐름도 UML로 그리기? UML이 모지? 

## CS 질문
프로세스 vs. 스레드
데드락(Deadlock)
가상 메모리
페이지
세그먼테이션
동기화
뮤텍스
세마포어
임계영역(Critical Section)
상호배제
동기 vs. 비동기

## 자료구조
자료구조 비교
Stack vs. Queue
Array vs. List 
ArrayList vs. LinkedList
이진트리
Full Binary Tree vs. Complete Binary Tree
Binary Heap
Binary Search Tree (BST)
이진트리 순회
해시테이블
HashTable
Hash Function
Resolve Collision
Open Addressing (개방 주소법)
Separate Chaining (분리 연결법) 
그래프
Graph Implement
Adjacent matrix (인접 행렬)
Adjacent list (인접 리스트)
Graph Search
DFS
BFS


## 알고리즘
알고리즘의 성능 분석
빅 오 표현법 살피기
아래 알고리즘들의 Time complexity, Space complexity 분석하기
수학 및 논리퍼즐
소수인지 판별하기(효율적인 개선점 찾기)
피보나치 수 구하기(Recursion 방법을 사용하지 않고 구현하기)
팩토리얼 구하기
문자열
역순으로 출력하기
가운데 글자 가져오기
애너그램 판단하기
정렬
Bubble sort, Insertion sort, Selection sort를 구현하고 설명하기
Quick sort, Merge sort를 구현하고 설명하기
Radix sort를 구현하고 설명하기
검색
Binary search 구현하기
비트
2의 제곱수인지 판별한다.
두 수에서 다른 비트의 개수를 구한다. 

1. 정렬
Bubble Sort
n개의 원소를 가진 배열을 정렬할 때, 인접한 두 개의 데이터를 비교해가면서 정렬을 진행하는 방식
가장 큰 값을 배열의 맨 끝에다 이동시키면서 정렬하고자 하는 원소의 개수만큼을 두 번 반복
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {3, 5, 2, 4, 1};

        // 인접한 원소 끼리 비교해서 큰 값을 뒤로 밀어낸다
        // 한 번 반복할 때마다 끝에 수가 하나씩 확정됨
        for(int i = 0; i < arr.length - 1; i++) {
            for(int j = 0; j < arr.length - i - 1; j++) {
                if(arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                }
            }
        }

        for(int num : arr)
            System.out.print(num + " ");
    }


    public static void swap(int[] arr, int a, int b) {
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
Selection Sort
n개의 원소를 가진 배열을 정렬할 때, 계속해서 바꾸는 것이 아닌 비교하고 있는 값의 index를 저장해둠.
최종적으로 한번만 바꾼다 ( 버블 소트랑 다를건 없는 듯 )
public class SelectionSort {
    public static void main(String[] args) {
        int[] arr = {3, 5, 2, 4, 1};

          // 최소값의 인덱스를 찾아서 앞으로 넣어준다
        for(int i = 0; i < arr.length - 1; i++) {
            int minIdx = i;
            for(int j = i + 1; j < arr.length; j++) {
                if(arr[minIdx] > arr[j]) {
                    minIdx = j;
                }
            }
            swap(arr, i, minIdx);
        }

        for(int num : arr)
            System.out.print(num + " ");
    }

    public static void swap(int[] arr, int a, int b) {
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
Insertion Sort
n 개의 원소를 가진 배열을 정렬할 때, i 번째를 정렬할 순서라고 가정하면, 0 부터 i-1 까지의 원소들은 정렬되어있다는 가정하에, i 번째 원소와 i-1 번째 원소부터 0 번째 원소까지 비교하면서 i 번째 원소가 비교하는 원소보다 클 경우 서로의 위치를 바꾸고, 작을 경우 위치를 바꾸지 않고 다음 순서의 원소와 비교하면서 정렬해준다. 이 과정을 정렬하려는 배열의 마지막 원소까지 반복해준다.
public class InsertionSort {
    public static void main(String[] args) {
        int[] arr = {3, 5, 2, 4, 1};
        int i, j;

        // 0 ~ i - 1까지는 정렬이 되어있음
        // i번째 원소를 정렬되어 있는 영역에 삽입한다
        for(i = 1; i < arr.length; i++) {
            int tmp = arr[i];

            for(j = i - 1; j >= 0; j--) {
                if(tmp > arr[j])
                    break;
                else
                    arr[j + 1] = arr[j];
            }
            arr[j + 1] = tmp;
        }

        for(int num : arr)
            System.out.print(num + " ");
    }


    public static void swap(int[] arr, int a, int b) {
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
Quick Sort
분할 정복을 이용한 빠른 정렬
Divide 과정에서 pivot이라는 개념을 사용
입력된 배열에 대해 오름차순으로 정렬한다고 하면 이 pivot 을 기준으로 좌측은 pivot 으로 설정된 값보다 작은 값이 위치하고, 우측은 큰 값이 위치하도록 partition된다.
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {3, 5, 2, 4, 1};

        myQuickSort(arr, 0, arr.length - 1);

        for(int num : arr)
            System.out.print(num + " ");
    }


    public static void myQuickSort(int[] arr, int left, int right) {
        if(left >= right)
            return;

        int pivot = partition(arr, left, right);

          // pivot 왼쪽에는 pivot보다 작은 수들만 있음, 걔들끼리 다시 정렬
        myQuickSort(arr, left, pivot - 1);
          // pivot 오른쪽에는 pivot보다 큰 수들만 있음, 걔들끼리 다시 정렬
        myQuickSort(arr, pivot + 1, right);
    }


    public static int partition(int[] arr, int left, int right) {
        int mid = (left + right) / 2;
        swap(arr, left, mid);

        int pivot = arr[left];
        int i = left, j = right;

        while(i < j) {
            while(pivot <= arr[j])
                j--;
            while(i < j && pivot >= arr[i])
                i++;
            swap(arr, i, j);
        }

        arr[left] = arr[i];
        arr[i] = pivot;

        return i;
    }


    public static void swap(int[] arr, int a, int b) {
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
Merge Sort
Merge Sort는 더이상 나누어지지 않을 때 까지 반 씩 분할하다가 더 이상 나누어지지 않은 경우(원소가 하나인 배열일 때)에는 자기 자신, 즉 원소 하나를 반환한다. 원소가 하나인 경우에는 정렬할 필요가 없기 때문이다. 이 때 반환한 값끼리 combine될 때, 비교가 이뤄지며, 비교 결과를 기반으로 정렬되어 임시 배열에 저장된다. 그리고 이 임시 배열에 저장된 순서를 합쳐진 값으로 반환한다. 실제 정렬은 나눈 것을 병합하는 과정에서 이뤄지는 것이다.
public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {3, 5, 2, 4, 1};

        myMergeSort(arr, 0, arr.length - 1);

        for(int num : arr)
            System.out.print(num + " ");
    }


    public static void myMergeSort(int[] arr, int left, int right) {
        if(left < right) {
            int mid = (left + right) / 2;

              // 왼쪽, 오른쪽으로 분할
            myMergeSort(arr, left, mid);
            myMergeSort(arr, mid + 1, right);

              // 병합을 진행하며 정렬시킨다
            merge(arr, left, mid, right);
        }
    }


    public static void merge(int[] arr, int left, int mid, int right) {
        int idx = left;
        int i = left, j = mid + 1;
        int[] tmp = new int[arr.length];

          // 왼쪽 배열과, 오른쪽 배열을 비교하며 임시배열에 작은 순서대로 넣는다
        while(i <= mid || j <= right) {
            if(j > right || (i <= mid && arr[i] < arr[j])) {
                tmp[idx++] = arr[i++];
            } else {
                tmp[idx++] = arr[j++];
            }
        }

        for(int s = left; s <= right; s++)
            arr[s] = tmp[s];
    }



    public static void swap(int[] arr, int a, int b) {
        int tmp = arr[a];
        arr[a] = arr[b];
        arr[b] = tmp;
    }
}
Sorting Algorithm's Complexity 정리
img

stable sort
정렬 알고리즘이 안전하다는 뜻은, 같은 값들을 정렬할 때 입력한 순서대로 출력된다는 것을 보장하는 것이다
Heap Sort, Quick Sort는 빠르지만 안전하지 못하다
팀소트가 nlgn에 안전한 정렬이지만, 여기까지는 생략하겠음

2. 재귀
함수 내부에서 함수가 자기 자신을 호출하여 문제를 해결하는 알고리즘
계속해서 자신을 호출하는 구조이므로 함수를 끝내는 조건이 반드시 필요하다
public class Factorial {
    static int[] cache = new int[10];
    public static void main(String[] args) {
        System.out.println(loopFactorial(5));
        System.out.println(recurFactorial(5));
        System.out.println(dpFactorial(5));
    }

      // 반복문으로 풀이
    public static int loopFactorial(int n) {
        int ret = 1;
        for(int i = 1; i <= n; i++) {
            ret *= i;
        }

        return ret;
    }

      // 재귀함수로 풀이
    public static int recurFactorial(int n) {
        if(n == 1)
            return 1;

        return n * recurFactorial(n - 1);
    }


      // 재귀함수 + 메모이제이션 풀이
    public static int dpFactorial(int n) {
        if(n == 1)
            return 1;

        int ret = cache[n];
        if(ret != 0)
            return ret;

        return cache[n] = n * dpFactorial(n - 1);
    }
}
3. 수학
최대공약수, 최소공배수
// 유클리드 호제법
// 최소공배수 = (n1 * n2) / (n1과 n2의 최대공약수)

public class GCD_LCM {
    public static void main(String[] args) {
        System.out.println(gcd(8, 12));

        int LCM = (8 * 12) / gcd(8, 12);
        System.out.println(LCM);
    }


    public static int gcd(int a, int b) {
        if(b == 0) return a;
        return gcd(b, a % b);
    }
}
에라토스테네스의 체(소수 판별)
public class Eratosthenes {
    public static void main(String[] args) {
        int size = 1000;

          // prime[n] = false -> n은 소수가 아니다
        boolean[] prime = new boolean[size + 1];
        Arrays.fill(prime, true);

          // 1은 소수가 아니므로 미리 처리
        prime[1] = false;
        for(int i = 2; i <= size; i++) {
            if(prime[i]) {
                  // 2의 배수들, 3의 배수들.... i의 배수들까지 소수가 아니다!
                for(int j = i + i; j <= size; j += i)
                    prime[j] = false;
            }
        }

    }
}


1. 이분 탐색
미리 배열을 정렬을 해야 사용할 수 있음
binarySearch
숫자가 중복되지 않는 배열에서 목표 숫자의 인덱스를 찾는다
O(logN)
upperBound
숫자가 중복된 배열에서, 목표 숫자보다 큰 첫번째 인덱스를 찾는다
lowerBound
숫자가 중복된 배열에서, 목표 숫자의 첫번째 인덱스를 찾는다
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {0, 1, 2, 3, 4, 4, 5, 6, 7};
        System.out.println(binarySearch(arr, 4));
        System.out.println(upperBound(arr, 4));
        System.out.println(lowerBound(arr, 4));
    }


    public static int binarySearch(int[] arr, int target) {
        int lo = 0, hi = arr.length;

        while(lo <= hi) {
            int mid = (lo + hi) / 2;

            if(arr[mid] <= target) {
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }

        return hi;
    }


    public static int upperBound(int[] arr, int target) {
        int lo = 0, hi = arr.length;

        while(lo < hi) {
            int mid = (lo + hi) / 2;

            if(arr[mid] <= target) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }

        return hi;
    }


    public static int lowerBound(int[] arr, int target) {
        int lo = 0, hi = arr.length;

        while(lo < hi) {
            int mid = (lo + hi) / 2;

            if(arr[mid] < target) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }

        return hi;
    }
}

6. 허프만 코딩
입력 파일의 문자 빈도 수를 가지고 최소힙을 이용하여 파일을 압축하는 과정
고정 길이 코드(fixed length code) vs 접두어 코드(prefix code)
고정 길이 코드는 대표적으로 아스키 코드가 있다. 아스키 코드는 항상 8bit의 길이를 가지고있다. 다루기에는 간단하지만, 저장 공간 활용에 있어서 제한이 있다. 이를 해결하기 위해서 가변 길이 코드(variable length code)가 존재한다.

가변 길이 코드 중에서도 접두어 코드는, 앞서 나온 문자가 다음에 나올 문자의 접두어가 되면 안되는 특징을 가진 코드다. 예를 들면 다음은 접두어 코드가 아닌 예다.

a : 01
b : 101
c : 010

위 코드에서 01은 010의 접두어이기 때문에 접두어 코드가 아니다. 반면 다음은 접두어 코드의 예다.

a : 01
b : 10
c : 111

abc -> 고정 길이 코드였다면 24비트, 접두어 코드 0110111, 7비트 굉장한 압축!
빈도 수가 높은 문자에는 짧은 이진코드(허프만 코드)를 부여하고, 빈도 수가 낮은 문자에는 긴 이진코드를 부여하여 압축 효율을 높인다.


## 네트워크 
Get 방식 vs. Post 방식
Cookie vs. Session
Cache를 사용하는 이유는?
TCP vs. UDP
Forward vs. Redirect
웹서버와 웹클라이언트의 차이
HTTP
HTTP vs. HTTPS
http1 과 http2의 차이점을 설명해보라.
3-hands-shaking이란?
Restful API

1. 웹 동작 방식
img

브라우저 주소창에 http://www.test.com 입력 후 엔터를 눌렀을 때 부터 페이지가 렌더링되는 과정
local DNS 서버에게 www.test.com에 해당하는 ip주소가 있는지 물어본다. 있다면 바로 해당 ip로 받아온다.
local DNS 서버에 없다면 루트 DNS 서버에 물어본다. 있다면 바로 해당 ip로 받아온다.
루트 DNS 서버에 없다면 .com 을 관리하는 DNS 서버에 물어본다. 있다면 바로 해당 ip를 받아온다.
.com 을 관리하는 DNS 서버에 없다면, test.com을 관리하는 DNS 서버에 물어본다. 있다면 바로 해당 ip를 받아온다.
목적지의 ip를 알게되었으니 TCP 통신을 통해 소켓을 개방한다.
HTTP 프로토콜로 요청한다.
만약 라우팅 중 프록시 서버를 만난다면 웹 캐시에 저장된 정보를 response 받는다.
프록시 서버를 만나지 못해 www.test.com을 서빙하는 서버까지 간다면 서버에서 요청에 맞는 데이터를 response로 전송한다.
브라우져의 loader가 해당 response를 다운로드할지 말지 결정을한다.
브라우져의 웹 엔진이 다운로드한 .html 파일 렌더링
OSI 7 계층과 연관지은 것
브라우저가 URL에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청을 합니다. 이 때, Domain으로 요청을 보낼 수 없기 때문에 DNS Lookup을 수행합니다.

DNS 룩업 과정은 크롬의 경우 브라우저 → hosts 파일 → DNS Cache의 순서로 도메인에 매칭되는 ip를 찾습니다. 일반적으로 설명하는 DNS Lookup은 루트 도메인서버에서부터 서브도메인 서버순으로 찾게됩니다.

이 요청은 프로토콜 스택이라는 OS에 내장된 네트워크 제어용 소프트웨어에 의해 패킷에 담기고 패킷에 제어정보를 덧붙여 LAN 어댑터에 전송하고, LAN 어댑터는 이를 전기신호로 변환시켜 송출합니다.

패킷은 스위칭 허브 등을 경유하여 인터넷 접속용 라우터에서 ISP로 전달되고 인터넷으로 이동합니다.
액세스 회선에 의해 통신사용 라우터로 운반되고 인터넷의 핵심부로 전달됩니다. 고속 라우터들 사이로 목적지까지 패킷이 흘러들어가게 됩니다.

핵심부를 통과한 패킷은 목적지의 LAN에 도착하고, 방화벽이 패킷을 검사한 후 캐시 서버로 보내어 웹 서버에 갈 필요가 있는지 검사합니다.

웹 서버에 도착한 패킷은 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘깁니다. 애플리케이션은 요청에 대한 응답 데이터를 작성하여 클라이언트로 회송하고, 이는 전달된 방식 그대로 전송됩니다.


1. OSI 7 계층
ISO(국제표준화기구)에서 네트워크 통신 과정을 7단계로 정의한 국제통신표준규약

Physical : 전송하는데 필요한 기능 제공 (통신 케이블, 허브)
Data Link : 송/수신 확인, MAC Address로 통신 (브릿지, 스위치)
Network : IP를 기반으로 데이터(패킷) 전송 경로 결정 (라우팅)
Transport : TCP/UDP 포트 정보를 참조해 데이터의 전송
Session : 통신 시스템 사용자 간의 연결을 유지 및 설정
Presentation : 세션 계층 간의 주고받는 인터페이스를 일관성 있게 제공
Application : 사용자가 네트워크에 접근할 수 있도록 서비스를 제공
5. ARP, RARP
ARP	RARP
공통점	-네트워크 계층에서 사용되는 주소 결정 프로토콜	
차이점	IP 주소에서 MAC 주소를 알아냄	MAC 주소에서 IP 주소를 알아냄
상대방 MAC 주소를 모를 때, IP와 브로드 캐스팅 네트워크 주소 FFFFFFFFFFFF를 가지는 ARP 패킷을 네트워크에 전송하여 이를 수신한 호스트가 자신의 MAC 주소를 반송하는 메커니즘
6. 로드 밸런서
로드밸런서는 서버에 가해지는 부하(=로드)를 분산(=밸런싱)해주는 장치 또는 기술을 통칭합니다. 클라이언트와 서버풀(Server Pool, 분산 네트워크를 구성하는 서버들의 그룹) 사이에 위치하며, 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 퍼포먼스를 보일 수 있도록 합니다.

Scale-up의 경우 서버 자체의 성능을 확장하는 것을 의미합니다. 비유하자면 CPU가 i3인 컴퓨터를 i7으로 업그레이드하는 것과 같습니다. 반면 Scale-out의 경우 기존 서버와 동일하거나 낮은 성능의 서버를 두 대 이상 증설하여 운영하는 것을 의미합니다. CPU가 i3인 컴퓨터를 여러 대 추가 구입해 운영하 것에 비유할 수 있습니다.
Scale-out의 방식으로 서버를 증설하기로 결정했다면 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드밸런싱이 반드시 필요합니다.

7. 주요 프로토콜 포트
프로토콜	포트 번호	내용
HTTP	80	웹을 지원하기 위한 프로토콜. GET, PUT 같은 프로토콜 기능을 포함해서 웹 서버에게 어떠한 Content를 요청하고 또는 웹 서버로 정보를 보냄
FTP	20, 21	TCP를 활용해 대량의 파일을 송신하고 수신하는 프로토콜
TFTP	69	UDP를 사용하는 파일 전송 프로토콜, 라우터나 스위치 등의 네트워크 장 비의 IOS 이미지를 업로드, 다운로드할 때 사용
Telenet	23	원격지에 있는 장비로 표준 터미널 에뮬레이션 기능을 제공함. 네트워크 장비에서는 텔넷을 통해 원격지에서 장비를 설정
SMTP	25	컴퓨터 네트워크를 통해 전자 메일을 전송하는 프로토콜. 받을 때는 POP3 를 활용
SNMP	161	네트워크 장비를 모니터링하고 제어하기 위해 사용하는 프로토콜로 네트워 크 장애 관리, 장비 설정, 통계 성능 및 보안 등을 관리
DNS	53	도메인 주소를 IP ADDRESS로 변경, 모든 퍼블릭 IP 주소와 호스트 이름 은 DNS에 저장되고 나중에 해당 IP 주소로 변환




## Java 질문
- 자바 인터페이스
Java 구동원리는?
Java 메모리에 대해 설명
가비지 컬렉터는 무엇인가?
자바 컬렉션 프레임워크 사용 이유와 종류
대표적인 3가지 인터페이스는?
인터페이스 vs. 추상클래스
오버로딩 vs. 오버라이딩
객체 vs. 클래스
super vs. this
fianl 키워드란?
static 키워드란?
NullPointerException 의미와 대처법
Wrapper class에 대해서 설명
String, Stringbuffer, Stringbuilder의 비교
== 와 Equals() 메서드의 차이
자바 스레드 구현
제네릭 이유와 사용법
람다식
리플렉션
JDBC Statement vs PrepareStatement
페이징 작업 로직
















## Java8 질문
Interceptor가 뭔지, 어떤 경우에 사용하는지


## Spring Framework 질문
- SpringBoot 
- SpringBatch 
- AOP로 구축하면 더 좋았을걸 하는... Redis 로그 적재 툴
Framework vs. Library
Spring Framework 란?
스프링의 장점
DI, loC
AOP란 무엇이고 왜 사용하는지
application context에 대해서 설명하시오
Dispatcher Servlet
빈(Bean)
빈팩토리(Bean Factory)
스프링 컨테이너
Scope(스코프)란?
오토와이어링이란 무엇인가?
filter vs intercepter
Spring boot
스프링 환경설정 혼자 잡을 수 있는가? 대강 어떻게 해야하는지 설명해 보시오.




 

 
 
 
[ Spring AOP의 작동 원리(JDK 동적 프록시와 CGLib 프록시) ]

다이내믹 프록시 객체의 생성 요청
포인트컷을 통해 부가 기능 대상 여부 확인
어드바이스로 부가 기능 적용
실제 기능 처리

 
Spring AOP는 기본적으로 JDK 동적 프록시를 이용하며, 자바의 인터페이스와 스프링 컨테이너 외에는 특별한 기술이나 환경을 필요로 하지 않습니다. 하지만 이러한 프록시 방법은 다음과 같은 2가지 단점을 가지고 있습니다.

프록시 적용을 위해 반드시 인터페이스를 생성해야 함
구체 클래스로는 빈을 주입받을 수 없고, 반드시 인터페이스로만 주입받아야 함

그래서 이러한 문제를 해결하고자 클래스 상속을 기반으로 프록시를 구현하는 CGLib 프록시가 등장하게 되었습니다. CGLib 프록시는 상속을 기반으로 구현되므로 final 클래스나 final 메소드면 프록시 생성이 불가능한 제약이 있습니다.
 
 
[ AspectJ AOP의 작동 원리 ]
Spring AOP가 아닌 또 다른 강력한 AOP 프레임워크 중 하나인 AspectJ는 프록시를 이용하지 않았습니다. 대신 AspectJ는 타깃 클래스 파일의 바이트 코드를 조작하여 부가기능을 직접 넣어주는 방법(위빙)을 사용합니다. 그래서 우리가 만든 코드에서는 부가 기능이 분리되어 있지만 바이트 코드에서는 핵심 기능과 부가 기능이 섞여있는 구조입니다. AspectJ가 프록시를 사용하지 않고 어려운 복잡한 바이트 조작 방법을 사용하는 이유는 크게 2가지가 있습니다.

바이트 코드를 조작하면 Spring과 같은 컨테이너의 도움이 필요 없기 때문이다.
프록시 방식보다 훨씬 강력하고 유연한 AOP를 제공할 수 있다.

 
바이트 코드를 끼워넣는 시점은 컴파일 시점과 클래스 파일이 JVM 메모리로 올라가는 시점 총 2가지가 있습니다.
 
 
[ 쓰레드 로컬(Thread Local) ]
스프링 MVC는 멀티 쓰레드 기반으로 동작하는 웹 프레임워크이다. 매번 요청이 올 때마다 쓰레드를 만들어 실행하면 비용이 커지므로, 쓰레드를 미리 만들어두고 쓰레드 풀에 쓰레드를 넣어뒀다가 요청이 오면 꺼내서 사용하고 반환한다. 
ThreadLocal은 각 쓰레드에 할당되는 저장 공간인데, 스프링과 같은 멀티 쓰레드 프로그래밍 환경에서 쓰레드 로컬에 값을 저장하고 해제하지 않으면 문제가 발생한다. 왜냐하면 쓰레드가 재사용되기 때문이다. 
대표적으로 Spring Security에서 사용되는 SecurityContextHolder는 ThreadLocal을 사용된다.
 
 
[ Spring WebFlux란? ]
Spring WebFlux란 Blocking+동기 방식으로 동작하는 Spring MVC의 한계점을 극복하기 위해 Spring5에 처음 등장하게 되었습니다. 기존의 Spring MVC에서는 HTTP 요청들을 큐에 넣어두고, 멀티쓰레드를 기반으로 동작하고 있습니다. 하지만 이러한 방식은 응답성이 상대적으로 떨어지기 때문에 비동기적으로 요청을 처리하기 위한 방법이 필요하게 되었고, 리액티브 프로그래밍을 통해 비동기 데이터 스트림으로 Non-Blocking 애플리케이션을 개발하기 위한 Spring WebFlux 프레임워크가 등장하게 되었습니다.
 
 
[ CDN(Content Delivery Network)란? ]
CDN(Content Delivery Network)는 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공하기 위해 고안된 기술입니다. 만약 우리나라에 있는 사람이 미국에 있는 서버로부터 이미지나 파일 등을 다운받으려고 하면 시간이 오래 걸립니다. 따라서 느린 응답속도와 다운로드 시간을 극복하기 위해 서버를 분산시켜 캐싱해두고, 빠르게 다운받을 수 있게 합니다.
CDN은 콘텐츠에 대한 요청이 발생하면 사용자와 가장 가까운 위치에 존재하는 서버로 매핑시켜, 요청된 파일의 캐싱된(사전 저장된) 버전으로 요청을 처리합니다. 서버가 파일을 찾는 데 실패하는 경우 CDN 플랫폼의 다른 서버에서 콘텐츠를 찾은 다음 엔드유저에게 응답을 전송합니다. 

 
 
 
출처: https://mangkyu.tistory.com/95 [MangKyu's Diary:티스토리]



1.  SPRING MVC(***)
Mvc 패턴의 처리 과정
?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F2DzgI%2FbtqLbmQS4ME%2FFtFEkEk1eKadKXXu399WD0%2Fimg

클라이언트(Client)가 서버에 어떤 요청(Request)을 한다면 스프링에서 제공하는 DispatcherServlet 이라는 클래스(일종의 front controller)가 요청을 가로챈다.
요청을 가로챈 DispatcherServlet은 HandlerMapping(URL 분석등..)에게 어떤 컨트롤러에게 요청을 위임하면 좋을지 물어본다.
요청에 매핑된 컨트롤러가 있다면 @RequestMapping을 통하여 요청을 처리할 메서드에 도달한다.
컨트롤러에서는 해당 요청을 처리할 Service를 주입(DI)받아 비즈니스로직을 Service에게 위임한다.
Service에서는 요청에 필요한 작업 대부분(코딩)을 담당하며 데이터베이스에 접근이 필요하면 DAO를 주입받아 DB처리는 DAO에게 위임한다.
DAO는 mybatis(또는 hibernate등) 설정을 이용해서 SQL 쿼리를 날려 DB에 저장되어있는 정보를 받아 서비스에게 다시 돌려준다.(이 때, 보통 Request와 함께 날아온 DTO 객체(@RequestParam, @RequestBody, ...)로 부터 DB 조회에 필요한 데이터를 받아와 쿼리를 만들어 보내고, 결과로 받은 Entity 객체를 가지고 Response에 필요한 DTO객체로 변환한다.)
모든 비즈니스 로직을 끝낸 서비스가 결과물을 컨트롤러에게 넘긴다.
결과물을 받은 컨트롤러는 필요에 따라 Model객체에 결과물 넣거나, 어떤 view(jsp)파일을 보여줄 것인지등의 정보를 담아 DispatcherServlet에게 보낸다.
DispatcherServlet은 ViewResolver에게 받은 뷰의 대한 정보를 넘긴다.
ViewResolver는 해당 JSP를 찾아서(응답할 View를 찾음) DispatcherServlet에게 알려준다.
DispatcherServlet은 응답할 View에게 Render를 지시하고 View는 응답 로직을 처리한다.
결과적으로 DispatcherServlet이 클라이언트에게 렌더링된 View를 응답한다.
12. MVC 1, MVC2
imageimage

mvc1
웹 브라우저의 요청을 jsp가 처리, jsp가 컨트롤러와 뷰 기능을 모두 담당
개발이 쉽지만, 유지 보수가 어려움
mvc2
웹 브라우저 요청을 서블릿이 처리함
구조가 복잡하지만 유지보수, 확장에 용이하다
13. 스프링 시큐리티
참조 링크
 
Spring Boot + Spring Security + JWT + Redis + JPA

JPA 1. 기본 개념 ORM Object-Relational Mapping 객체와 관계형 데이터 베이스 매핑, 객체와 DB의 테이블이 매핑을 이루는 것 객체가 테이블이 되도록 매핑 시켜주는 프레임워크이다 프로그램의 복잡도를

ltk3934.tistory.com



1.  JPA 개념
참조 링크
 
Spring Boot + Spring Security + JWT + Redis + JPA

JPA 1. 기본 개념 ORM Object-Relational Mapping 객체와 관계형 데이터 베이스 매핑, 객체와 DB의 테이블이 매핑을 이루는 것 객체가 테이블이 되도록 매핑 시켜주는 프레임워크이다 프로그램의 복잡도를

ltk3934.tistory.com

16. JPA 영속성 컨텍스트
영속성 컨텍스트는 엔티티를 영구 저장하는 환경을 의미합니다.

영속성 컨텍스트를 쓰는 이유는 1차 캐시, 동일성 보장, 쓰기 지연, 변경감지(Dirty checking), 지연로딩이 있습니다.

1차 캐시: 조회가 가능하며 1차 캐시에 없으면 DB에서 조회하여 1차 캐시에 올려 놓습니다.
동일성 보장: 동일성 비교가 가능합니다.(==)
쓰기 지연: 트랜잭션을 지원하는 쓰기 지연이 가능하며 트랜잭션 커밋하기 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있습니다.
변경 감지(Dirty checking): 스냅샷을 1차 캐시에 들어온 데이터를 찍습니다. commit 되는 시점에 Entity와 스냅샷과 비교하여 update SQL을 생성합니다.
지연 로딩: 엔티티에서 해당 엔티티를 불러올 때 그 때 SQL을 날려 해당 데이터를 가져옵니다.

17. JPA Propagation
JPA Propagation은 트랜잭션 동작 도중 다른 트랜잭션을 호출(실행)하는 상황에 선택할 수 있는 옵션입니다.

@Transactional의 propagation 속성을 통해 피호출 트랜잭션의 입장에서는 호출한 쪽의 트랜잭션을 그대로 사용할 수도 있고, 새롭게 트랜잭션을 생성할 수도 있습니다.

REQUIRED(디폴트): 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성합니다.

18. JPA 사용 이유
JPA를 사용하는 이유는 객체지향 프레임워크이기 때문입니다. JPA를 사용하면 비즈니스 로직이 RDBMS에 의존하는 것이 아니라, 자바 코드로 표현될 수 있기 때문입니다. 그로 인해서 생산성이 높아진다고 볼 수 있습니다.

또, JPA는 JPQL로 SQL을 추상화하기 때문에 RDBMS Vendor에 관계없이 동일한 쿼리를 작성해서 같은 동작을 기대할 수 있다는 장점도 가지고 있습니다. 이는 database dialect를 지원하기 때문에 가지는 장점입니다.


## DB 기술 면접 질문 
데이터베이스 정규화의 이유
기본 문법 
Group by란?
where과 having의 차이
서브쿼리란?
조인의 비교(Inner join, Outer join, Natual join 등)
DB 설계 시 키의 종류와 특징
- 기본키, 외래키를 다른 말로 뭐라고 하는지, 그 외에 어떤 키들이 있는지

인덱스는 무엇이고 용도는?
뷰의 용도는?
트랜잭션(커밋, 롤백)이란 무엇인가?
NoSQL이란?
가장 길었던 SQL문이 몇 줄이었는가?
비효율적인 쿼리의 성능은 어떻게 높일 수 있는가?
SQL로 데이터베이스를 다루기가 여의치 않을 때는 무엇을 할 수 있는가?

정규화
이상 현상이 발생하는 테이블을 수정하여 정상으로 만드는 과정
정규화를 하기 위해서는 테이블을 분석하여 기본키와 함수 종속성을 파악해야 함
함수 종속성
어떤 속성 A의 값을 알면 다른 속성 B의 값이 유일하게 정해지는 의존 관계를 '속성 B는 속성 A에 종속한다' 라고 함
A -> B라고 표기, A는 B의 결정자
정규화 과정
이상현상이 있는 릴레이션은 이상현상을 일으키는 함수 종속성의 유형에 따라 등급을 구분할 수 있음
릴레이션은 정규형이라는 개념으로 구분
제 1 정규형
릴레이션의 속성 값이 원자값이어야 한다
제 2 정규형
릴레이션 R이 제 1 정규형이고 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때
이상현상을 일으키는 속성을 분리한다
제 3 정규형
속성들이 이행적으로 종속되어 있는지 여부
이행적으로 종속되어 있는 속성을 분리한다
BCNF
릴레이션에 존재하는 함수 종속성에서 모든 결정자가 후보키이면 BCNF
4, 5정규화도 존재하지만, 보통 쓰지 않는다

트랜잭션
트랜잭션 개념
트랜잭션은 DBMS에서 데이터를 다루는 논리적인 작업의 단위
트랜잭션은 장애 발생 시 데이터를 복구하는 작업의 단위가 된다
트랜잭션은 여러 작업이 동시에 같은 데이터를 다룰 때 이 작업을 서로 분리하는 단위가 된다
트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야 한다
트랜잭션 수행 과정
시작(begin)
수행
부분완료
버퍼내용 기록
완료(commit)
트랜잭션의 성질
원자성
전부 수행되거나 전혀 수행되지 않아야 한다

START TRANSACTION
COMMIT
ROLLBACK
SAVE
일관성
트랜잭션을 수행한 전후 데이터베이스는 항상 일관된 상태여야 한다

무결성 제약 조건을 지켜야 한다
고립성
수행중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다

동시성 제어
트랜잭션 고립 수준을 통한 상호 간섭 완화
지속성
수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다

트랜잭션이 정상적으로 완료 혹은 부분완료한 데이터는 반드시 데이터베이스에 기록되어야 함
시스템이 멈추어도 트랜잭션 수행으로 변경된 내용은 디스크에 기록된다
동시성 제어
트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능
갱신 손실 문제
두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생
해결책
락
갱신 손실 문제를 해결하려면 상대방 트랜잭션이 데이터를 사용하는지 여부를 알 수 있는 규칙이 필요
락을 이용하여 자신이 사용할 데이터를 잠그면 다른 트랜잭션은 잠금이 풀릴 때까지 기다려야 한다
락의 유형
공유락
트랜잭션이 읽기를 할 때 사용되는 락
배타락
읽기 / 쓰기를 할 때 사용되는 락
다른 트랜잭션이 데이터에 공유락을 걸어두면, 공유락의 요청은 허용하고 배타락은 허용하지 않음
다른 트랜잭션이 데이터에 배타락을 걸어두면, 공유락과 배타락 모두 허용하지 않음


데이터베이스 시스템
데이터 베이스 특징
실시간 접근성
계속적인 변화
동시 공유
내용에 따른 참조
DBMS의 장점
데이터의 독립성
물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
논리적 독립성 : 데이터베이스는 논리적인 구조로 다양항 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
데이터의 무결성
여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
데이터의 보안성
인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.
데이터의 일관성
연관된 정보를 논리적은 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.
데이터 중복 최소화
데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.
데이터 베이스 개념적 구조
외부 스키마
전체 데이터베이스 중에서 하나의 논리적인 부분
서브 스키마라고도 하며, 뷰의 개념
여러 개의 외부 스키마가 있을 수 있음
개념 스키마
전체 데이터베이스의 정의
하나의 데이터베이스에는 하나의 개념 스키마가 존재
물리 스키마
물리적 저장장치에 데이터베이스가 실제로 저장되는 방법을 표현
인덱스, 데이터 레코드의 배치 방법, 데이터 압축 등에 관한 사항 포함
관계 데이터 모델
키
슈퍼키
튜플을 유일하게 식별할 수 있는 하나의 속성 혹은 집합
후보키
튜플을 유일하게 식별할 수 있는 속성의 최소 집합
기본키
여러 후보키 중 하나를 선정하여 대표로 삼는 키 ( primary key )
외래키
다른 릴레이션의 기본키를 참조하는 속성
무결성 제약 조건
데이터 무결성
데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것
도메인 무결성 제약조건
릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건
개체 무결성 제약조건 (기본키 제약)
기본키는 null 값을 가져서는 안되며 릴레이션 내에 오직 하나의 값만 존재해야 한다
참조 무결성 제약조건 (외래키 제약)
자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 하며, 자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다
SQL
DML - 검색
SELECT [ ALL | DISTINCT ] 속성 이름
FROM 테이블 이름
WHERE 검색 조건
GROUP BY 속성 이름
HAVING 검색 조건
ORDER BY 속성 이름 [ASC | DESC]
DML - INSERT
INSERT INTO 테이블이름(속성 리스트)
                values (값 리스트)
DML - UPDATE
UPDATE 테이블 이름
SET 속성이름 = 값
WHERE 검색조건
DML - DELETE
DELETE FROM 테이블 이름 WHERE 검색조건
DDL - CREATE
CREATE TABLE 테이블 이름
    ( {속성 이름, 데이터 타입 [NULL | NOT NULL | UNIQUE | DEFAULT 기본값 | CHECK 체크조건]}
      PRIMARY KEY 속성이름
       FOREIGN KEY 속성이름 REFERENCES 테이블이름
       ON DELETE {CASCADE | SET NULL}
  )
DDL - ALTER
ALTER TABLE 테이블 이름
    ADD 속성이름 데이터타입
    DROP COLUMN 속성이름
    ALTER COLUMN 속성이름 데이터 타입
    ALTER COLUMN 속성이름 [NULL | NOT NULL]
    ADD PRIMARY KEY(속성이름)
    [ADD | DROP] 제약이름
DDL - DROP
DROP TABLE 테이블이름
인덱스
인덱스란?
자료를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조
원하는 데이터를 빨리 찾기 위해 튜플의 키 값에 대한 물리적 위치를 기록해둔 자료구조
RDBMS의 인덱스는 대부분 B-TREE 구조로 되어있음
img

B-tree
B-tree의 각 노드는 키 값과 포인터를 가진다
항상 정렬상태를 유지, 균형 상태 유지
검색할 때 특유의 트리 구조를 이용하기 때문에 한 번 검색할 때마다 검색 대상이 줄어 접근 시간이 적게 걸림
데이터의 변경이나 추가가 잦을 경우 B-tree의 모양을 유지하기 위해 노드의 분할 및 이동이 자주 발생하는 단점이 있음
인덱스 특징
테이블에서 한 개 이사의 속성을 이용하여 생성
빠른 검색과 함께 효율적인 레코드 접근
순서대로 정렬된 속성과 데이터의 위치만 보유하므로 테이블보다 작은 공간을 차지
저장된 값들은 테이블의 부분집합이 됨
데이터의 수정, 삭제 등의 변경이 발생하면 인덱스의 재구성이 필요함
클러스터 인덱스, 보조 인덱스
클러스터 인덱스
연속된 키 값의 레코드를 묶어서 같은 블록에 저장하는 방법
B-tree 인덱스의 리프 노드에서 페이지의 주소 값 대신 테이블의 열 자체가 저장되는 형태
보조 인덱스
속성의 값으로 B-tree 인덱스를 구성하며 리프 노드의 각 행은 해당 페이지의 주소 값을 저장
인덱스 생성
데이터의 양이 별로 없거나 데이터 값이 몇 종류 안되어 선택도가 높을 경우 인덱스가 없는 게 더 빠를 수 있음
의미 없이 인덱스를 생성하면 검색이 더 느려지고 저장 공간만 낭비
CREATE INDEX ix_Book ON BOOK(bookname)

- 인덱스 / 캐시
- RDB 특징 
  - Oracle/MySQL  
- 디비 모델링 관련 질문
- 디비 모델링 한거 리스트 작성
- 라이브커머스 예고
- 웰컴 서비스 
- 피드 서비스
- 플래그십 탭메뉴 
- 플래그십 모듈
- 플래그십 마스터


## API란 
- RESTful API 
- HETEOS 
- HTTP API
- 웹소켓 통신


## Redis


## Laravel Framework 



## Elastic Search + Kibana
- 기본개념 
- 엘라스틱 서치 운영/개발 이력 정리

## Logstash 
- 기본개념 
- 로그스테시 사용 이력 정리 

## Kafka
- 기본개념 
  - RabbitMQ 차이 
  - 메시지 큐의 특징

- 카프카 사용 이력 정리

## Magento
- 마젠토 1->2 버젼업 레퍼런스 자료 어떻게 찾았는지? 
- 요구사항 분석 설계 어떤 식으로 하였는지? 
- 마젠토 1,2 차이가 어떻게 잇었는지? 


## 대용량 Traffic 설계/개발
- 피드서비스 CJ온스타일 서버 진입시 호출 최다 -> Redis Cache 처리
    -> 배치 데이터 처리, API 비동기성 개발   
    -> CJmall은 행사 때 주로 넷버넬 사용.. 

## 디자인패턴 
### 싱글톤 
#### 싱글턴 패턴은 어떻게 사용하는가?
### 팩토리 메서드 패턴 
### 옵저버 패턴
### 템플릿 메서드 패턴은 어떻게 사용하는가?

### 퍼싸드 패턴
### 스트레티지 패턴
### 가장 기억에 남는 디자인 패턴과 그 이유는?
### 빌더 패턴은 얼마나 유용한가?
### 스트레티지 패턴의 예를 보여줄 수 있는가?

### 일반적으로 사용하는 패턴
### 데커레이터 패턴의 예를 설명할 수 있는가?
### 플라이웨이트 패턴의 구현 방법을 설명할 수 있는가?
https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-designpattern.html

[ 디자인 패턴 ]

생성 패턴

팩토리 패턴: 객체를 생성하기 위한 디자인 패턴
추상 팩토리 패턴: 객체를 생성하는 팩토리를 생성하기 위한 디자인 패턴
빌더 패턴: 상황에 따라 동적인 인자를 필요로 하는 객체를 생성하기 위한 디자인 패턴
싱글톤 패턴: 객체를 1개만 생성하여 항상 참조가능하도록 고안된 디자인 패턴


구조 패턴

어댑터 패턴: 호환성이 맞지 않는 두 클래스를 연결하여 사용하기 위한 디자인 패턴
프록시 패턴: 어떤 객체에 접근 제어를 위해 대리인을 사용하는 디자인 패턴
데코레이터 패턴: 어떤 객체에 새로운 기능 추가를 위해 대리인을 사용하는 디자인 패턴
퍼사드 패턴: 어떤 복합적인 기능에 대해 간략화된 인터페이스를 제공하는 디자인 패턴


행위 패턴

전략 패턴: 상황에 따라 다른 전략을 사용하기 위한 디자인 패턴
옵저버 패턴: 값을 관찰하여 빠르게 반영하기 위한 디자인 패턴
커맨드 패턴: 실행될 기능을 캡슐화하여 재사용성이 높은 클래스를 설계하기 위한 디자인 패턴



DatabaseController=> SingletonPattern을 사용하여 데이터베이스를 제어하는 하나의 인스턴스만을 생성
DatabasePool => ObjectPool Pattern을 사용하여 데이터베이스 객체를 미리 생성하여 Performance 향상
UnitFactory => FactoryPattern을 사용하여 객체 생성을 최적화 + Singleton Pattern을 사용하여 하나의 공장을 사용
BaseFrame => ObserverPattern을 사용하여 사용자의 정보가 생신되면 View의 값들도 갱신되게 함
PlayerInfo => StrategyPattern을 사용하여 상황에 따라 다른 스킬을 사용

디자인 패턴이란?
자주 사용하는 설계 패턴을 정형화 해서 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계
알고리즘과 유사하지만, 명확하게 정답이 있는 형태는 아니며, 프로젝트의 상황에 맞추어 적용 가능
생성 패턴
객체를 생성하는 것과 관련된 패턴으로, 객체의 생성과 변경이 전체 시스템에 미치는 영향을 최소화 하고, 코드의 유연성을 높여준다
Factory Method
Singleton
Prototype
Builder
Abstract Factory
구조 패턴
프로그램 내의 자료구조나 인터페이스 구조 등 프로그램 구조를 설계하는데 활용될 수 있는 패턴
클래스, 객체들의 구성을 통해서 더 큰 구조를 만들 수 있게 해준다
Adapter
Composite
Bridge
Decorator
Facade
Proxy
행위 패턴
반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로, 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 제공함
Template Method
Interpreter
Iterator
Observer
Strategy
Singleton Pattern(**)
Singleton 패턴은 어떠한 클래스가 유일하게 1개만 존재할 때 사용함
image

디폴트 생성자를 막는다
static으로 getInstance()를 만든다
Instance가 Null인 경우 새로 생성
Adapter Pattern
호환성이 없는 기존 클래스의 인터페이스를 변환하여 재사용 할 수 있도록 함
image

인터페이스끼리 호환시키려고 할 때, 중간에 Adapter 클래스를 만들어서 사용함
Proxy Pattern
Proxy는 대리인이라는 뜻, 뭔가를 대신해서 처리하는 것
Proxy Class를 통해서 대신 전달하는 형태로 설계되며, 실제 Client는 Proxy로부터 결과를 받음
Cache의 기능으로도 활용 가능
Spring에서 Proxy를 이용해 AOP를 구현했다
image

Observer Pattern
관찰자 패턴은 변화가 일어났을 때, 미리 등록된 다른 클래스에 통보해주는 패턴을 구현한 것
Event listener에서 이런 패턴을 사용하고 있음
image

Facade Pattern(**)
Facade는 건물의 앞쪽 정면이라는 뜻
여러 개의 객체와 실제 사용하는 서브 객체의 사이에 복잡한 의존 관계가 있을 때, 중간에 facade라는 객체를 두고 Interface만을 활용하여 기능을 사용하는 방식
image

image

원래는 개별로 의존성 관리를 해야하는데, 한 곳에 모아서 관리한다
Strategy Pattern(*****)
객체 지향의 핵심
유사한 행위들을 캡슐화하여, 객체의 행위를 바꾸고 싶은 경우 직접 변경하는 것이 아닌 전략만 변경하여 유연하게 확장하는 패턴
image

기본 Encoder는 그대로 두고, 전략만을 바꿔 넣어서 결과 값을 다르게 만든다!
전략 메서드를 가진 전략 객체(Normal Strategy , Base64 Strategy)
전략 객체를 사용하는 컨텍스트 ( Encoder )
전략 객체를 생성해 컨텍스트에 주입하는 클라이언트





개발상식
OOP(객체지향)이란?
객체는 무엇인가?
MVC 패턴
MVC 1 vs. MVC 2 
함수형 프로그래밍 
콜백함수란?
익명클래스, 익명객체
컴포넌트 vs. 모듈
Call by Reference, Call by Value
JSON, XML
Servlet vs. JSP
아스키코드 vs. 유니코드
TDD 란 무엇인가? 
Git 과 GitHub에 대해서 
WAS와 웹서버의 차이점은? 웹 컨테이너란?
애자일 방법론에 대해서 아는가?
UML
메모리 누수
프로젝트 개발 순서
보안/공격
Sql injection
xss
해시함수와 암호화
Junit
Junit 테스트를 통해 얻는 가치는 무엇인가?
Junit 테스트는 어떻게 실행하는가?
Junit 테스트 생명주기
Junit 테스트를 실행할 때 어떤 일이 일어나는가?
Junit 사용의 좋은 예
테스트가 성공인지 어떻게 증명할 수 있는가?
어떻게 특정 예외를 예상할 수 있는가?
테스트가 예상햇던 시간 안에 완료되지 않으면, 테스트가 실패되게 만들 수 있는가?
@RunWith 어노테이션은 어떻게 작동하는가?
실행중인 테스트들을 사용자화하려면 어떻게 해야 하는가?
목으로 의존성 제거하기
단위 테스트와 통합 테스트의 차이는 무엇인가?
테스트의 의미가 더 잘 표현되게 하려면 어떤 방법을 사용해야 하는가?
행위 주도 개발 이용해 시스템 테스트 만들기
행위 주도 개발이란 무엇인가?
웹 애플리케이션
톰캣과 서블릿 API
서블릿 API는 어떻게 웹 애플리케이션을 정의하는가?
특정 서블릿의 요청을 안전하게 관리하려면 어떻게 해야 하는가?
WAR 파일이란 무엇인가?
톰캣은 웹 애플리케이션을 어떻게 관리하는가?
서블릿 API에서 요청 매개변수들을 어떻게 처리하는가?
제티
자바 크랠스 안에서 실행되는 웹 애플리케이션을 어떻게 생성할 수 있는가?
실행 중인 웹 서버에서 어떻게 통합 테스트를 수행할 수 있는가?
어떻게 로컬 애플리케이션 서버에서 활발한 개발을 수행할 수 있는가?
플레이 프레임워크
새로운 플레이 애플리케이션은 어떻게 만드는가?
플레이 애플리케이션의 다른 구성 요소는 무엇인가?
HTTP 요청의 결과로 자바 코드는 어떻게 실행되는가?
플레이 프레임워크에서 생성되는 HTML 코드와 자바 코드는 어떻게 구분하는가?
어떻게 플레이에서 JDBC 데이터베이스를 이용할 수 있는가?
유용한 라이브러리들
아파치 Commons 이용해 기본 코드 제거하기
문자열을 적절히 처리하려면 어떻게 해야 하는가?
OutputStream 객체에 InputStream 객체를 어떻게 저장하는가?
OutputStream 객체를 어떻게 두 개의 스트림 객체로 나눌 수 있는가?
Guava 컬렉션 이용해 개발하기
자바의 표준 라이브러리에서 빠진 컬렉션들의 종류는 무엇인가?
불변 컬렉션은 어떻게 생성하는가?
몇몇 Iterator 목록에 대한 Iterator 객체를 생성하는 것이 가능한가?
두가지 Set 객체 사이의 교집합을 찾을 수 있는가?
Joda Time 이용하기
DataTime 클래스를 어떻게 이용하는가?
Joda Time을 사용할 때 자바의 Date 객체와 함께 사용하려면 어떻게 해야 하는가?
Joda Time의 Duration과 Period 클래스의 차이점은 무엇인가?
특정 날짜를 사람이 읽을 수 있는 형식으로 어떻게 변환하는가?
빌드 도구 이용해 개발하기
메이븐 이용해 애플리케이션 빌드하기
메이븐이란 무엇인가?
메이븐을 사용하려면 프로젝트를 어떻게 구성해야 하는가?
메이븐 빌드의 생명주기는 무엇인가?
메이븐에 특정 애플리케이션 빌드를 어떻게 정의하는가?
만들어진 결과물을 어떻게 애플리케이션 사이에 공유할 수 있는가?
각기 다른 골을 특정 메이븐 상태에 어떻게 바인드할 수 있는가?
앤트
어떻게 앤트를 이용해 빌드를 구성하는가?
앤트와 메이븐을 함께 통합할 수 있는가?
10. 세션이 무엇인가?
11. 세션과 쿠키의 차이점?
- 쿠키와 로컬 저장소의 차이점?
12. ajax.. 동기 통신과 비동기 통신의 차이점



[ 많은 트래픽이 발생한 경우 대처하는 방법 ]

스케일 업(Scale Up): 서버에 CPU나 RAM 등을 추가하여 서버의 하드웨어 스펙을 향상시키는 방법이다.
스케일 아웃(Scale Out): 서버를 여러 대 추가하여 시스템을 증가시키는 방법이다.
출처: https://mangkyu.tistory.com/95 [MangKyu's Diary:티스토리]

 


[ 절차지향 프로그래밍 VS 객체지향 프로그래밍 ]

절차지향 프로그래밍

물이 위에서 아래로 흐르는 것처럼 순차적인 처리를 중요시하는 프로그래밍 기법이다.
가장 대표적인 언어로 C언어가 있다.
컴퓨터의 처리구조와 유사해 실행속도가 빠르다.
코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다.


객체지향 프로그래밍

실제 세계의 사물들을 객체로 모델링하여 개발을 진행하는 프로그래밍 기법
가장 대표적인 언어로 Java가 있다.
캡슐화, 상속, 다형성 등과 같은 기법을 이용할 수 있다. 다형성은 동일한 키보드의 키가 다른 역할을 하는 것처럼 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것을 의미한다.
절치지향 언어보다 실행속도가 느리다.






 
 



 

 
 
[ 병렬 처리 프레임워크의 종류와 특징 ]

 Hadoop

HDFS(Hadoop Distributed File System)를 활용해 데이터를 주고 받는다.
데이터가 여러 노드에 분산되어 저장되기 때문에 손실의 우려가 없다는 장점이 있다.
하지만 File I/O를 기반으로 작동하기 때문에 처리 속도가 느리다.


Spark

In-Memory 상 에서 데이터를 주고받고 연산을 수행한다.
메모리를 사용해 데이터를 처리하기 때문에 Hadoop보다 속도가 약 100배 정도 빠르다.
하지만 메모리상에서 처리하기 때문에 장애가 발생한 경우 응용 프로그램을 처음부터 다시 시작해야 한다.





 
 
 
 
1. 프로그래밍 공통 - 고급

[ 메세지 큐(Message Queue)란? ]
메세지 큐(Message Queue)란 Queue 자료구조를 이용하여 데이터(메세지)를 관리하는 시스템으로, 비동기 통신 프로토콜을 제공하여 메세지를 빠르게 주고 받을 수 있게 해준다. 메세지 큐에서는 Producer(생산자)가 Message를 Queue에 넣어두면, Consumer가 Message를 가져와 처리하게 된다. 메세지 큐에는 Kafka, Rabbit MQ, AMPQ 등이 있다.
 
[ Docker(도커)와 Kubernates(쿠버네티스) ]
Docker는 컨테이너 기반의 가상화 기술입니다. 기존에는 하드웨어를 가상화하였기 때문에 Host OS 위에 Guest OS를 설치해야 했습니다. 하지만 이러한 방식은 상당히 무겁고 느려 한계가 많이 있었습니다.
그래서 이를 극복하고자 프로세스를 격리시킨 컨테이너를 통해 가상화를 하는 Docker(도커)와 같은 기술들이 등장하게 되었고, 도커를 통해 구동되는 컨테이너를 관리하기 위한 Kubernates(쿠버네티스)가 등장하게 되었습니다.
 
 
[ Docker(도커)의 장/단점 ]

장점

쉽고 빠른 실행 환경 구축
하드웨어 자원 절감
Docker Hub와 같은 공유 환경 제공


단점

개발 초기의 오버헤드
Linux 친화적





 
[ 해시 테이블와 해시 테이블의 시간 복잡도 ]
해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용합니다. 해시 테이블은 Key값에 해시함수를 적용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조입니다.

해시 테이블은 고유한 index로 값을 조회하기 때문에 평균적으로 O(1)의 시간복잡도를 갖습니다. 하지만 해시의 index값이 충돌이 발생한 경우 충돌된 index값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하기 때문에 O(N)까지 증가할 수 있습니다.
 




 
 


 
 
1. 자료구조 - 고급

[ AVL 트리 ]
AVL 트리란 한 쪽으로 값이 치우치는 이진 균형 트리(Balanced Search Tree, BST)의 한계점을 보완하기 위해 만들어진 균형 잡힌 이진 트리입니다. AVL은 항상 좌/우로 데이터를 균형잡힌 상태로 유지하기 위해 추가적인 연산을 진행합니다.
 
 
[ 레드블랙 트리 ]
레드블랙 트리는 모든 노드를 빨간색 또는 검은색으로 색칠합니다. 그리고 연결된 노드들은 색이 중복되지 않도록 관리됩니다.
출처: https://mangkyu.tistory.com/89 [MangKyu's Diary:티스토리]

3. 알고리즘 
 
[ 동적 프로그래밍(Dynamic Programming)이란? ]
동적 프로그래밍(Dynamic Programming) 이란 주어진 문제를 풀기 위해서, 문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 해결하는 방식입니다. 동적 프로그래밍에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization) 기법으로 속도를 향상 시킬 수 있습니다. 
 
 
[ 동적 프로그래밍(Dynamic Programming)의 두 가지 조건 ]
동적 프로그래밍(Dynamic Programming)으로 문제를 해결하기 위해서는 주어진 문제가 다음의 조건을 만족해야 한다.
 

Overlapping Subproblem(중복되는 부분문제): 주어진 문제는 같은 부분 문제가 여러번 재사용된다.
Optimal Substructure(최적 부분구조): 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구할 수 있다.

 
 
[ 재귀 알고리즘과 재귀의 시간 복잡도 ]
재귀 알고리즘이란 함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는 알고리즘입니다. 재귀 알고리즘은 자기가 계속해서 자신을 호출하므로 끝없이 반복되게 되므로 반복을 중단할 조건이 반드시 필요합니다.
팩토리얼을 계산하는 재귀 함수에서는 T(n) = T(n-1) + c (C는 n과 f(n-1)을 곱하는 비용)을 조회하고 점화식을 계산하면 아래와 같이 O(n)이 됨을 보일 수 있습니다.
T(n) = T(n-1) + c
     = T(n-2) + 2c
     = T(n-3) + 3c
     = ……
     = T(2) + (n-2)c
     = T(1) + (n-1)c
     ≤ c + (n-1)c = c + cn - c = cn --> O(n)
 
 
[ 팩토리얼의 재귀/반복문 손코딩 ]
    private static int recursiveFactorial(int num) {
        if(num > 1) {
            return recursiveFactorial(num - 1) * num;
        }
        return 1;
    }

    private static int loopFactorial(int num) {
        int answer = 1;
        for (int i = 2; i <= num; i++) {
            answer *= i;
        }
        return answer;
    }
 
 
[ 피보나치 수열 재귀/반복문 손코딩 ]
    private static int recursiveFibonacci(int index) {
        if (index <= 2){
            return 1;
        }
        return recursiveFibonacci(index - 1) + recursiveFibonacci(index - 2);
    }

    private static int loopFibonacci(int index) {
        int answer = 1;
        int before = 1;
        int temp;
        for (int i = 2; i < index; i++) {
            temp = answer;
            answer += before;
            before = temp;
        }
        return answer;
    }
 
 
1. 알고리즘 - 고급

[ n개의 배열에서 k(k<=n) 번째로 큰수를 찾는 알고리즘 ]
이러한 문제를 해결하기 위해 일반적으로 퀵정렬을 사용합니다. 하지만 퀵정렬을 사용하면 정렬이 불필요한 부분들을 정렬하면서 효율적이지 못하게 됩니다. 퀵선택 알고리즘은 퀵정렬을 한 후에 피봇과 K를 비교하여 아래와 같이 수행합니다.

pivot의 인덱스가 k와 같은 경우 : 그대로 그 인덱스의 값을 리턴하면 된다.
pivot의 인덱스가 k보다 작은 경우 : pivot의 인덱스+1부터 마지막 인덱스까지 다시 Partition함수에 넘겨준다.
pivot의 인덱스가 k보다 큰 경우 : 첫번째 인덱스부터 pivot의 인덱스-1까지 다시 Partition함수에 넘겨준다.

퀵정렬 알고리즘과의 다른 점은 예를 들어 Pivot의 인덱스가 7이고 K가 5인 경우에, 피봇의 오른쪽 부분은 재귀 함수를 돌지 않아 한 쪽만으로 재귀를 진행하는 것입니다.
이러한 이유로 퀵선택 알고리즘의 시간복잡도는 𝑛+𝑛/2+4/𝑛+....1=𝑂(𝑛)n+n/2+4/n+....1=O(n)n + n/2 + 4/n + .... 1 = O(n) 입니다.

 
[ 허프만 코딩이란 ]
허프만 코딩은 문자의 빈도를 이용해 압축하는 방법으로 빈도가 높은 문자에 짧은 코드를 부여합니다. 허프만 코드는 접두부 코드와 최적 코드를 사용합니다.

접두부 코드: 문자에 부여된 코드가 다른 이진 코드의 접두부가 되지 않는 코드
최적코드: 인코딩된 메세지의 길이가 가장 짧은 코드


 
[ 특정 수 이하의 3과 5의 배수의 합 구하기 손코딩 ]
    private static int addMultipleOf3And5(int maxNum) {
        int div = maxNum / 3;
        int sum3 = (1 + div) * div * 3 / 2 ;
        div = maxNum / 5;
        int sum5 = (1 + div) * div * 5 / 2 ;
        div = maxNum / 15;
        int sum15 = (1 + div) * div * 15 / 2 ;
        return sum3 + sum5 - sum15;
    }
출처: https://mangkyu.tistory.com/90 [MangKyu's Diary:티스토리]


4. 네트워크 
 
 
[ 공인 IP와 사설 IP 차이 ]
 

공인 IP

전세계에서 유일한 IP로 ISP(인터넷 서비스 공급자)가 제공하는 IP주소
외부에 공개되어 있기 때문에 인터넷에 연결된 다른 장비로부터 접근이 가능하다. 
그에 따라 방화벽 등과 같은 보안 설정을 해주어야 한다.


사설 IP

어떤 네트워크 안에서 사용되는 IP주소
 IPV4의 부족으로 인해 모든 네트워크가 공인 IP를 사용하는 것이 불가능하기 때문에 네트워크 안에서 라우터를 통해 할당받는 가상의 주소이다. 
별도의 설정 없이는 외부에서 접근이 불가능하다.



 
 
[ 웹 접근성의 국제표준 ]
웹 접근성을 높이기 위해 고안된 웹 표준은 웹에서 표준적으로 사용되는 기술이나 규칙을 의미합니다. 웹 표준을 정하기 위하 W3C(World Wide Web Consortium)이 설립되었으며 웹 표준으로 구조 언어인 HTML, 표현 언어인 CSS, 동작 언어인 Script를 지정하였습니다.
-> 작성한 내용이 틀렸다면 지적해주세요!!
 
 
[ OSI 7계층 ]

 

7 계층(응용 계층): 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층
6 계층(표현 계층): 데이터의 형식(Format)을 정의하는 계층
5 계층(세션 계층): 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
4 계층(전송 계층): 최종 수신 프로세스로 데이터의 전송을 담당하는 계층
3 계층(네트워크 계층): 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층
2 계층(데이터링크 계층): 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층
1 계층(물리 계층): 데이터를 전기 신호로 바꾸어주는 계층

 
 


 


1. 운영체제

[ Byte Ordering이란 ]
Byte Ordering이란 데이터가 저장되는 순서를 의미합니다. Byte Ordering의 방식에는 빅엔디안(Big Endian)과 리틀엔디안(Little Endian)이 있습니다.

Big Endian

MSB가 가장 낮은 주소에 위치하는 저장 방식
네트워크에서 데이터를 전송할 때 주로 사용됨
가장 낮은 주소에 MSB가 저장되므로, offset=0인 Byte를 보면 양수/음수를 바로 파악할 수 있다.


Little Endian

MSB가 가장 높은 주소에 위치하는 방식
마이크로프로세서에서 주로 사용된다.
가장 낮은 주소에 부호값이 아닌 데이터가 먼저 오기 때문에, 바로 연산을 할 수 있다. 












 
[ 세마포어(Semaphore) vs 뮤텍스(Mutex) 차이 ]
뮤텍스는 Locking 메커니즘으로 락을 걸은 쓰레드만이 임계 영역을 나갈때 락을 해제할 수 있습니다. 하지만 세마포어는 Signaling 메커니즘으로 락을 걸지 않은 쓰레드도 signal을 사용해 락을 해제할 수 있습니다. 세마포어의 카운트를 1로 설정하면 뮤텍스처럼 활용할 수 있습니다.
 
 
 
 
[ CPU의 메모리 I/O 도중 생기는 병목 현상 해결 방법 ]
이러한 문제를 해결하기 위해 메모리를 계층화하여 병목현상을 해결하고 있습니다. 자주 접근하는 데이터의 경우에는 캐시에 저장하여 접근 속도를 향상 시킴으로써 부하를 줄이고 있습니다.
 
 
 
1. 운영체제 - 고급

[ 가상메모리와 페이지폴트 ]

가상메모리는 RAM의 부족한 용량을 보완하기 위해, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식입니다. OS는 프로세스들의 내용(페이지) 중에서 덜 중요한 것들을 하드디스크에 옮겨 놓고, 관련 정보를 페이지 테이블에 기록합니다. CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데, 실제메모리에 원하는 페이지가 없는 상황이 발생할 수 있습니다(Valid bit를 통해 확인). 이것을 페이지 폴트라고 하는데 프로세스가 동작하면서 실제메모리에 필요한 데이터(페이지)가 없으면 가상메모리를 통해서 해당 데이터를 가져오게 됩니다. 가상메모리는 하드디스크에 저장되어 있기 때문에, 페이지폴트가 발생하면 I/O에 의한 속도의 저하가 발생합니다.
 
 
[ 페이지 교체 알고리즘과 LRU(Least Recently Used) ]
LRU(Least Recently Used)는 페이지를 교체하기 위한 알고리즘 중 하나입니다.
페이지를 교체하는 이유는 가상메모리를 통해 조회한 페이지는 다시 사용될 가능성이 높기 때문입니다. 페이지 교체를 위해서는 실제메모리에 존재하는 페이지를 가상메모리로 저장한 후에, 가상메모리에서 조회한 페이지를 실제메모리로 로드해야 됩니다. 그렇다면 어떤 실제메모리의 페이지를 가상메모리로 희생시킬 것이냐에 대한 문제가 발생하는데, 이때 사용하는 알고리즘 중 하나가 LRU(Least Recently Used) 알고리즘 입니다.
LRU 알고리즘은 실제메모리의 페이지들 중에서 가장 오랫동안 사용되지 않은 페이지를 선택하는 방식입니다. 그 외에도 먼저 적재된 페이지를 희생시키는 FIFO(First In First Out) 알고리즘이나 LRU 알고리즘을 응용하여 페이지에 Second-Change를 주는 LRU Approximation 등이 있습니다.
 
출처: https://mangkyu.tistory.com/92 [MangKyu's Diary:티스토리]




6. 데이터베이스

[ 인덱스(index)란? ]
인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸린다. 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같다.
데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.
만약 Index를 적용하지 않은 컬럼을 조회한다면, 전체를 탐색하는 Full Scan이 수행된다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.
 
 
[ 인덱스의 자료구조 ]

해시 테이블

컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다.
시간복잡도가 O(1)이라 검색이 매우 빠르다.
 부등호(<, >)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하다.


B+Tree

자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다.
BTree의 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 하였다.
해시 테이블보다 나쁜 O(𝑙𝑜𝑔2𝑛log2n{log_2n}) 의 시간복잡도를 갖지만 해시테이블보다 흔하게 사용된다.



 
 
[ DB 정규화 ]

제1정규형: 모든 속성 값이 원자 값을 갖도록 분해한다.
제2정규형: 제1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해한다.(여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미한다.)
제3정규형: 제2정규형을 만족하고, 기본키가 아닌 속성이 기본키에 직접 종속(비이행적 종속)하도록 분해한다.(여기서 이행적 종속이란 A->B->C가 성립하는 것으로, 이를 A,B와 B,C로 분해하는 것이 제3정규형이다.)
BCNF 정규형: 제3정규형을 만족하고, 함수 종속성 X->Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해한다.

 
[ 트랜잭션(Transaction)이란? ]
트랜잭션이란 데이터베이스 작업의 단위로써 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우 모든 과정을 되돌리기 위한 방법입니다.
 
 
[ 트랜잭션의 ACID란? ]

원자성(Atomicity): 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.
일관성(Consistency): 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
고립성(Isolation): 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야한다.
지속성(Durability): 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.

 
[ 이상 현상의 종류 ]

삭제 이상: 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
삽입 이상: 튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
수정 이상: 튜플 수정 시 중복된 데이터의 일부만 수정되어 일어나는 데이터 불일치 현상

 
[ DB 락의 종류 ]
DB 락은 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구이다.

공유락(LS, Shared Lock): 트랜잭션이 읽기를 할 때 사용하는 락, 데이터를 읽을 수 있지만 쓸 수 없음
베타락(LX, Exclusive Lock): 트랜잭션이 읽고 쓰기를 할 때 사용하는 락, 데이터를 읽고 쓸 수 있음

 



 
 
1. 데이터베이스 - 고급

[ 힌트(Hint)란? ]
힌트란 SQL을 튜닝하기 위한 지시구문입니다. 옵티마이저가 최적의 계획으로 SQL문을 처리하지 못하는 경우에 개발자가 직접 최적의 실행 계획을 제공하는 것입니다. 힌트는 아래와 같이 SELECT 다음에 작성할 수 있으며, INDEX, PARALLEL 등 다양한 힌트절이 있습니다.
# 사용가능한 힌트절: PARALLE, INDEX, FULL ...
SELECT /*+ [힌트절] */ 
 
[ 클러스터링 vs 리플리케이션 ]

리플리케이션

여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식이다.
비동기 방식으로 노드들 간의 데이터를 동기화한다.
장점: 비동기 방식으로 데이터가 동기화되어 지연 시간이 거의 없다.
단점: 노드들 간의 데이터가 동기화되지 않아 일관성있는 데이터를 얻지 못할 수 있다.


클러스터링

여러 개의 DB를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식이다.
동기 방식으로 노드들 간의 데이터를 동기화한다.
장점: 1개의 노드가 죽어도 다른 노드가 살아 있어 시스템을 장애없이 운영할 수 있다.
단점: 여러 노드들 간의 데이터를 동기화하는 시간이 필요하므로 Replciation에 비해 쓰기 성능이 떨어진다.



 
[ 데이터베이스 튜닝과 방법 ]
DB 튜닝은 테이터베이스의 구조나 데이터베이스 자체, 운영체제 등을 조정하여 데이터베이스 시스템의 성능을 향상시키는 작업을 의미합니다. 튜닝은 DB 설계 튜닝 -> DBMS 튜닝 > SQL 튜닝의 단계로 진행할 수 있습니다.

 
출처: https://mangkyu.tistory.com/93 [MangKyu's Diary:티스토리]

 
 
 
[ 클래스(Class), 객체(Object), 인스턴스(Instance)의 개념 ]

클래스(Class): 객체를 만들어내기 위한 설계도 혹은 틀
객체(Object): 설계도(클래스)를 기반으로 선언된 대상, 클래스의 인스턴스라고도 부름
인스턴스(Instance): 객체에 메모리가 할당되어 실제로 활용되는 실체

// 클래스
public class Person {
    private String name;
}

public class Main {

    public static void main(String[] args) {
        // 객체 = 클래스의 인스턴스
        Person person;
        
        // 인스턴스
        person = new Person();
    }
    
}
 
 
[ 싱글톤 패턴(Singleton Pattern) 구현 및 사용 이유 ]
public class Person {

    private static Person instance;
    
    public static Person getInstance() {
        if(instance == null){
            instance = new Person();
        }
        return instance;
    }
}
 
싱글톤 패턴은 단 하나의 인스턴스를 생성하여 사용하는 디자인패턴입니다. 싱글톤패턴은 아래의 경우에 사용합니다.

해당 인스턴스가 절대적으로 1개만 존재한다는 것을 보증하고 싶은 경우
동일한 인스턴스를 자주 생성해주어야 하는 경우(메모리 낭비의 방지)

하지만 이러한 싱글톤 패턴은 객체 지향 설계의 원칙에 적합하지 않으며, LifeCycle 제어가 힘들고, 멀티스레드 환경에서 여러 개의 객체가 생성되는 문제가 발생할 수 있습니다. 그러한 이유로 멀티스레드 환경이라면 static 앞에 synchronized 키워드를 붙여 동기화 작업을 추가해주어야 합니다.(당연히 성능이 저하됩니다).

 

 

 
[ synchronized란? ]
Java에서 지원하는 synchronized 키워드는 여러 쓰레드가 하나의 자원을 이용하고자 할 때, 한 스레드가 해당 자원을 사용중인 경우, 데이터에 접근할 수 없도록 막는 키워드입니다. synchronized 키워드를 이용하면 병렬 상황에서 자원의 접근을 안전하게 하지만, 자원을 이용하지 않는 쓰레드는 락에 의한 병목현상이 발생하게 됩니다.

메소드 synchronized: 한 시점에 하나의 쓰레드만이 해당 메소드를 실행할 수 있다.
변수 synchronized: 한시점에 하나의 쓰레드만이 해당 변수를 참조할 수 있다.

 
 


 

 
출처: https://mangkyu.tistory.com/94 [MangKyu's Diary:티스토리]

디자인 패턴이란?
자주 사용하는 설계 패턴을 정형화 해서 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계
알고리즘과 유사하지만, 명확하게 정답이 있는 형태는 아니며, 프로젝트의 상황에 맞추어 적용 가능
생성 패턴
객체를 생성하는 것과 관련된 패턴으로, 객체의 생성과 변경이 전체 시스템에 미치는 영향을 최소화 하고, 코드의 유연성을 높여준다
Factory Method
Singleton
Prototype
Builder
Abstract Factory
구조 패턴
프로그램 내의 자료구조나 인터페이스 구조 등 프로그램 구조를 설계하는데 활용될 수 있는 패턴
클래스, 객체들의 구성을 통해서 더 큰 구조를 만들 수 있게 해준다
Adapter
Composite
Bridge
Decorator
Facade
Proxy
행위 패턴
반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로, 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 제공함
Template Method
Interpreter
Iterator
Observer
Strategy
Singleton Pattern(**)
Singleton 패턴은 어떠한 클래스가 유일하게 1개만 존재할 때 사용함
image

디폴트 생성자를 막는다
static으로 getInstance()를 만든다
Instance가 Null인 경우 새로 생성

Adapter Pattern
호환성이 없는 기존 클래스의 인터페이스를 변환하여 재사용 할 수 있도록 함
인터페이스끼리 호환시키려고 할 때, 중간에 Adapter 클래스를 만들어서 사용함

Proxy Pattern
Proxy는 대리인이라는 뜻, 뭔가를 대신해서 처리하는 것
Proxy Class를 통해서 대신 전달하는 형태로 설계되며, 실제 Client는 Proxy로부터 결과를 받음
Cache의 기능으로도 활용 가능
Spring에서 Proxy를 이용해 AOP를 구현했다


Observer Pattern
관찰자 패턴은 변화가 일어났을 때, 미리 등록된 다른 클래스에 통보해주는 패턴을 구현한 것
Event listener에서 이런 패턴을 사용하고 있음
image

Facade Pattern(**)
Facade는 건물의 앞쪽 정면이라는 뜻
여러 개의 객체와 실제 사용하는 서브 객체의 사이에 복잡한 의존 관계가 있을 때, 중간에 facade라는 객체를 두고 Interface만을 활용하여 기능을 사용하는 방식
image

image

원래는 개별로 의존성 관리를 해야하는데, 한 곳에 모아서 관리한다
Strategy Pattern(*****)
객체 지향의 핵심
유사한 행위들을 캡슐화하여, 객체의 행위를 바꾸고 싶은 경우 직접 변경하는 것이 아닌 전략만 변경하여 유연하게 확장하는 패턴
image

기본 Encoder는 그대로 두고, 전략만을 바꿔 넣어서 결과 값을 다르게 만든다!
전략 메서드를 가진 전략 객체(Normal Strategy , Base64 Strategy)
전략 객체를 사용하는 컨텍스트 ( Encoder )
전략 객체를 생성해 컨텍스트에 주입하는 클라이언트






1. Apache, nginx 비교
Apache
멀티 프로세스 + 멀티 스레드
스레드풀에 미리 스레드를 만들어 놓는다
클라이언트 요청 하나에 스레드 하나 대응
Nginx
멀티 프로세스 + 싱글 스레드
worker 프로세스는 초당 수천개의 동시 접속과 요청을 처리할 수 있다
프로세스나 스레드에 대한 생성 / 파괴 패턴이 없기 때문에 빠르다!
3. RESTFUL
내용이 너무 길어서..

참조 링크
4. CORS(Cross Origin Resource Sharing)
도메인 또는 포트가 다른 서버의 자원을 요청하면 발생하는 이슈
Restful api를 사용하면 일어날 수 있다
5. Servlet, JSP
Servlet (자바 안에 html 넣은 거)
서블릿(servlet)은 서버에서 웹페이지 등을 동적으로 생성하거나 데이터 처리를 수행하기 위해 자바로 작성된 프로그램이다.
servlet은 Java코드 안에 HTML태그가 삽입되며 자바 언어로 되어있다.
클라이언트 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 servlet 클래스의 구현 규칙을 지킨 자바프로그램
JSP(Java Server Pages)(html 안에 자바 넣은 거)
HTML을 코딩하기 너무 어렵고 불편해서 HTML 내부에 Java코드를 삽입하는 형식이 JSP이다.

서블릿을 이용하게 되면 웹프로그래밍을 할 수 있지만 자바에 대한 지식이 필요하며 화면 인터페이스 구현에 너무 많은 코드를 필요로 하는 등 비효율적인 측면들이 있다. 때문에 서블릿을 작성하지 않고도 간편하게 웹프로그래밍을 구현하게 만든 기술이 JSP(Java Server Pages)이다.

mvc에서 활용
서블릿은 html 작성이 불편, 자바는 편함, jsp는 자바 작성 불편 html이 편함
mvc의 로직을 담당하는 컨트롤러는 서블릿이 맡고, 화면을 담당하는 뷰는 jsp가 맡자!!


1. Blocking, Non-Blocking
Blocking/NonBlocking은 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사다.

호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 NonBlocking이다.

그렇지 않고 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 Blocking이다.

?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcBveNG%2FbtqDY12Hdd0%2Fj3UtHIiNTNgy7fzVoDELl1%2Fimg




스래싱
반복적으로 페이지 폴트가 발생해서, 과도하게 페이지 교체 작업이 일어나, 실제로는 아무일도 하지 못하는 상황
세그멘테이션 기법
세그멘테이션은 크기가 다른 segment 단위로 물리 메모리에 로딩함
image

내부 단편화 (페이지 기법일 때)
페이지 블록만큼 데이터가 딱 맞게 채워져있지 않을 때 공간 낭비
외부 단편화 ( 세그멘테이션 기법일 때 )
물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우

스레드
Light Weight Process
프로세스
프로세스 간에는 각 프로세스의 데이터 접근이 불가 ( IPC 사용 )
스레드
하나의 프로세스에 여러 개의 스레드 생성 가능
스레드들은 동시에 실행 가능
프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능 ( IPC 사용할 필요가 없다 )
imageimage

Code 영역, Data 영역, Heap 영역은 다 같이 공유함
Stack 영역만 스레드마다 각각 유지
멀티 프로세싱과 스레드
멀티 태스킹과 멀티 프로세싱
멀티 태스킹 : 하나의 CPU가 여러 프로세스를 동시에 실행하도록 보이게 하는 기술
멀티 프로세싱 : 프로세스를 여러개의 CPU로 병렬 실행하여 CPU 속도를 높이는 것
멀티 프로세싱 원리
스레드를 여러개 만들면 가능!!
image

스레드 장점
사용자에 대한 응답성 향상
image

멀티 태스킹, 멀티 프로세싱처럼 동시에 실행되는 것처럼 느껴진다
자원 공유 효율
IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요없음
프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능
만약 동시 실행을 위해 스레드가 아닌 프로세스들을 만든다면 heap, code, data 영역들을 프로세스마다 새로 만들어줘야 함, 엄청난 메모리 낭비 -> 스레드는 프로세스 하나에서 자원들을 공유
스레드 단점
스레드 중 한 스레드만 문제가 있어도, 전체 프로세스가 영향을 받음
image

스레드를 많이 생성하면, 컨텍스트 스위칭이 많이 일어나서 성능이 저하됨
스레드를 많이 생성하면, 모든 스레드를 스케쥴링해야 함, 컨텍스트 스위칭이 빈번하다
스레드 vs 프로세스
프로세스는 독립적, 스레드는 프로세스의 서브셋
프로세스는 각각 독립적인 자원을 가진다, 스레드는 프로세스 자원 공유
프로세스는 자신만의 주소영역을 가진다, 스레드는 주소 영역 공유
프로세스간에는 IPC 기법으로 통신해야 함, 스레드는 필요 없음
동기화
동기화 이슈
동기화
작업들 사이에 실행 시기를 맞추는 것
여러 스레드가 동일한 자원 접근 시 동기화 이슈 발생
동일 자원을 여러 스레드가 동시 수정 시, 각 스레드 결과에 영향을 준다
해결 방안
Mutual Exclusion(상호 배제)
스레드는 프로세스 모든 데이터를 접근할 수 있으므로
여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access가 필요함
어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막는다
임계 영역
임계 자원
Mutex와 Semaphore
임계 구역에 대한 접근을 막기 위해 Locking 메커니즘이 필요함
Mutex (binary semaphore)
임계 구역에 하나의 스레드만 들어갈 수 있음
Semaphore
임계 구역에 여러 스레드가 들어갈 수 있음
counter를 두어서 동시에 리소스에 접근 할 수 있는 허용 가능한 스레드 수를 제어
바쁜 대기(busy waiting)
세마포어 카운터 값이 0이라면 임계 영역에 들어가기 위해, 계속 반복문을 실행한다
의미 없는 반복문 실행으로 성능 저하
대기큐 (Waiting Queue)
바쁜 대기를 피하기 위해서 세마포어 카운터 값이 음수가 된다면, 그 이후 스레드들을 대기 큐에 넣는다
카운터 값이 1 이상이 되면 대기 큐에 있던 스레드들을 깨운다
교착 상태 ( Deadlock )
무한 대기 상태
두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에. 다음 상태로 진행하지 못하는 상태
image

배치 처리 시스템에서는 일어나지 않는 문제!

프로세스, 스레드 둘 다 이와 같은 상태가 일어날 수 있음

기아 상태( Starvation )
특정 프로세스의 우선순위가 낮아서 원하는 자원을 할당 받지 못하는 상태
교착 상태와 기아 상태
교착 상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생
기아 상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당이 안되는 경우 발생
기아 상태 해결 방안
Aging
오래 기다린 프로세스의 우선순위를 높여준다


인터럽트
인터럽트란?
CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술
어느 한 순간 CPU가 실행하는 명령은 하나, 다른 장치와 어떻게 커뮤니케이션을 할까?

인터럽트 필요 이유
선점형 스케쥴러 구현
프로세스 running 중 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체하기 위해, 현재 프로세스를 중단시킴
io Device와의 커뮤니케이션
저장매체에서 데이터 처리 완료 시, 프로세스를 깨워야 함(block state -> ready state)
예외 상황 핸들링
CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생할 경우 CPU가 해당 처리를 할 수 있도록 CPU에 알려줘야 함
주요 인터럽트
Divide-by-Zero 인터럽트
타이머 인터럽트
선점형 스케쥴러를 위해 필요
하드웨어로부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려준다
입출력 인터럽트
인터럽트 종류
내부 인터럽트 -> 소프트웨어 인터럽트
주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
0으로 나눌 때
허용되지 않은 명령 또는 공간 접근
계산 결과 overflow / underflow
외부 인터럽트 -> 하드웨어 인터럽트
주로 하드웨어에서 발생하는 이벤트 (프로그램 외부)
전원 이상, 기계 문제, 키보드, Timer 이벤트
시스템 콜 인터럽트
시스템 콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어, CPU에게 실행시켜야 함
image

프로세스 변경할 때도 사용자 모드와 커널 모드로 수시로 바뀌면서 실행
인터럽트와 IDT
인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가 기록되어 있음
IDT(Interrupt Descriptor Table)에 기록되어 있음
컴퓨터 부팅 시 운영체제가 기록
항상 인터럽트가 발생하면, IDT를 확인
인터럽트와 프로세스
image

프로세스 실행 중 인터럽트 발생
현 프로세스 실행 중단
인터럽트 처리 함수 실행
현 프로세스 재실행
프로세스와 컨텍스트 스위칭
프로세스 구조
image

코드 영역
프로그램의 코드가 저장이 된다
데이터 영역
변수가 어떤 것들이 선언되어 있는지 데이터 영역에 저장
스택 영역
함수, 지역 변수, 콜 스택( 임시 데이터 )
힙 영역
동적으로 메모리 공간 할당
데이터 영역과 코드 영역은 고정된 영역
Data 영역
BSS
초기화 되지 않은 전역변수
Data
초기 값이 있는 전역변수
컨텍스트 스위칭
PCB
Program Counter, Stack Pointer는 어디에 저장하지?

Process Control Block(PCB)에 저장
프로세스가 실행중인 상태를 캡쳐 / 구조화해서 저장함
Process ID, Register 값, 스케쥴링 정보, 메모리 정보 등
Context Switching(문맥 교환)
CPU에 실행할 프로세스를 교체하는 기술
실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, 메인 메모리에 저장
다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보를 CPU에 넣고 실행
디스패치(dispatch) : ready 상태의 프로세스를 running 상태로 바꾸는 것

프로세스 간 커뮤니케이션 (IPC)
프로세스들이 서로의 공간을 쉽게 접근할 수 있다면, 얼마나 위험할까

프로세스는 다른 프로세스의 공간을 접근할 수 없다
여러 프로세스 동시 실행을 통한 성능 개선, 복잡한 프로그램을 위해 프로세스간 통신 필요ㅕ
프로세스간 통신 방법을 제공한다
파일을 사용한 커뮤니케이션
파일을 사용하면, 실시간으로 직접 원하는 프로세스에 데이터 전달이 어려움
커널 공간을 사용한 커뮤니케이션
프로세스끼리 커널공간은 공유된다

Message Queue
Shared Memory
Pipe
Signal
Semaphore
Socket
프로세스 총 정리
프로그램이 실행 되는 과정!!
코드를 컴파일 한다 -> 실행 파일이 만들어짐
쉘(gui, cli)을 사용해서 운영체제에 실행 파일 실행을 요청
프로세스 구조가 만들어짐
데이터 (BSS, DATA)
코드
스택
힙
스케쥴러 방식에 따라 실행이 된다 ( ready 상태에 진입 ) ( 예를 들어 선점형 라운드 로빈 방식 )
일정 시간마다 타이머 인터럽트가 발생한다
인터럽트를 처리
사용자 모드를 커널 모드로 바꿈
IDT(Interrupt Descriptor Table)에서 해당 주소를 찾아서 실행
컨텍스트 스위칭을 통해 내가 실행한 프로그램이 running 상태가 된다
PCB 정보를 CPU에 넣어준다
코드 영역 실행
실행 중, io 디바이스 처리 같은 시스템 콜을 만나면 block 상태로 전환(wait)
io 디바이스 처리가 완료 되면 다시 인터럽트 발생 -> wait 상태에서 ready 상태로 다시 전환


참고
https://yaboong.github.io/design-pattern/2018/09/28/thread-safe-singleton-patterns/


운영체제 구조
두 가지 모드
사용자 모드 : 응용 프로그램이 사용
커널 모드 : OS가 사용
시스템 콜은 커널 모드로 실행
커널 모드로 실행하려면, 반드시 시스템 콜을 거쳐야 함
시스템 콜은 운영체제가 제공
함부로 응용 프로그램이 전체 컴퓨터 시스템을 해치지 못함
프로세스 스케쥴링
배치 처리 시스템
자동으로 다음 응용 프로그램이 이어서 실행될 수 있도록 하는 시스템
FIFO - Queue를 사용
어떤 프로그램은 실행이 너무 오래 걸려서, 다른 프로그램이 실행하는데 시간을 많이 기다려야 한다
나는 MP3 음악을 들으면서, 문서 작성을 하고 싶음!
두 가지 프로그램을 동시에 실행할 수 없음
시분할 시스템
응용 프로그램이 CPU를 점유하는 시간을 잘게 쪼개어 실행될 수 있도록 하는 시스템
컴퓨터 응답 시간을 최소화 하는 시스템
멀티 태스킹
단일 CPU에서, 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템
멀티 프로세싱
여러 CPU에 하나의 프로그램을 병렬로 실행하여 실행속도를 극대화시키는 시스템
멀티 프로그래밍
최대한 CPU를 많이 활용하도록 하는 시스템
스케쥴링 알고리즘
프로세스
실행중인 프로그램은 프로세스라고 함
프로세스 : 메모리에 올려져서 실행중인 프로그램
작업, task, job이라는 용어와 혼용
FIFO 스케쥴러
프로세스가 저장매체를 읽는다는지, 프린팅을 한다든지 하는 작업 없이, 쭉 CPU를 처음부터 끝까지 사용

가장 간단한 스케쥴러(배치 처리 시스템)
FCFS(First Come First Served) 스케쥴러
Queue에 넣고 순서대로
최단 작업 우선(SJF) 스케쥴러
가장 프로세스 실행 시간이 짧은 프로세스부터 먼저 실행을 시키는 알고리즘
실행 시간을 다 알아야 가능한 것
여기서 잠깐!
RTOS(RealTime OS)
응용 프로그램 실시간 성능 보장을 목표로 하는 OS
정확하게 프로그램 시작, 완료 시간을 보장
GPOS(General Purpose OS)
프로세스 실행시간에 민감하지 않고, 일반적인 목적으로 사용되는 OS(windows, linux .. )
우선 순위 기반 스케쥴러
Priority-Based 스케쥴러
정적 우선순위
프로세스마다 우선순위를 미리 지정
동적 우선순위
스케쥴러가 상황에따라 우선순위를 동적으로 변경
라운드- 로빈 스케쥴러
프로세스가 끝나지 않아도 다른 프로세스로 넘겨준다
시분할 시스템 기반
큐를 사용해서 계속 돈다
프로세스 상태
image

ready : CPU에서 실행 가능 상태
blocked : 특정 이벤트 발생 대기 상태 (wait)
Queue 사용
Ready State Queue
Running State Queue
Block State Queue
선점형과 비선점형 스케쥴러
선정혐 스케쥴러
하나의 프로세스가 다른 프로세스 대신에 프로세스를 차지할 수 있음
비선점형 스케쥴러
하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음




출처: https://aspring.tistory.com/entry/기술면접-개발자-기술면접-시-예상-질문 [HelloSpring:티스토리]

출처: https://mangkyu.tistory.com/95 [MangKyu's Diary:티스토리]

출처: https://mangkyu.tistory.com/95 [MangKyu's Diary:티스토리]

<이력서/ 자기소개서 근거>
## 코드의 질, 운영유지보수 유연한 코드를 짜려면? 
- 리팩토링 
- 클린코드
- 이펙티브 자바
- 구글 코드 스타일
- 테스트 TDD 